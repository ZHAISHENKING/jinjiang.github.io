<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
  <!-- proud for contributing Vue.js -->
  <meta charset="utf-8">
  <meta name="format-detection" content="telephone=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-touch-fullscreen" content="yes">

  
  <title>
    
    用 Koa 写服务体验 -
    
    囧克斯
  </title>

  <link rel="stylesheet" href="/css/pure.css">
  <link rel="stylesheet" href="/css/style.css">
  <!--[if IE 6]>
    <link rel="stylesheet" href="/css/style-ie.css">
  <![endif]-->

  
  <link rel="alternate" href="/atom.xml" title="囧克斯" type="application/atom+xml">
  
  
  <link rel="icon" href="/favicon.png">
  
</head>

<body>

  <div id="wrapper">

    <div id="header">
      <h1>
        <a href="/" title="囧克斯">
          囧克斯
        </a>
      </h1>
      <p class="description">
        这里是勾三股四的新家
      </p>
    </div>

    <div id="nav" class="pure-menu pure-menu-open pure-menu-horizontal">
      <ul>
        
        <li>
          <a href="/all-demos/">
            线上
          </a>
        </li>
        
        <li>
          <a href="/all-slides/">
            线下
          </a>
        </li>
        
        <li>
          <a href="/about/">
            关于
          </a>
        </li>
        
      </ul>
    </div>

    <div id="main"><div class="content">
  <h2>
    用 Koa 写服务体验
  </h2>
  <p><img src="http://img2.tbcdn.cn/L1/461/1/5682414ab4dc8dd1b4ff91b0b57f96947c1c1c11" alt="Koa"></p>
<p>晒一下自己用 <a href="http://koajs.com/" target="_blank" rel="noopener">Koa</a> next generation web framework for node.js 写的一个 web 服务</p>
<p>这个 web 服务主要是做内容的列表展示和搜索的 (可能说得比较抽象，但确实是 web 服务最常需要做的事情) 主要的文件一共就2个：</p>
<ul>
<li><code>app.js</code> 主程序</li>
<li><code>lib/model.js</code> 数据层</li>
</ul>
<p>其中 <code>model.js</code> 是和具体业务逻辑相关的，就不多介绍了，这也不是 Koa 的核心；而 <code>app.js</code> 的代码可以体现 Koa 的很多优点，也使得代码可以写得非常简练而去清晰——这是我自己都完全没有想到的事情</p>
<a id="more"></a>
<h3 id="加载资源和相关依赖库"><a href="#加载资源和相关依赖库" class="headerlink" title="加载资源和相关依赖库"></a>加载资源和相关依赖库</h3><pre><code>// resources

var koa = require(&apos;koa&apos;)
var app = koa()

var logger = require(&apos;koa-logger&apos;)
var route = require(&apos;koa-route&apos;)

var fs = require(&apos;fs&apos;)
var path = require(&apos;path&apos;)
var extname = path.extname

var views = require(&apos;co-views&apos;)
var render = views(&apos;./views&apos;, {
  map: { html: &apos;ejs&apos; }
})

var model = require(&apos;./lib/model&apos;)
</code></pre><p>其中：</p>
<ol>
<li><code>koa</code> 是最核心的库，<code>app</code> 是 <code>koa</code> 生成的 web 服务主程序</li>
<li><a href="https://www.npmjs.com/package/koa-logger" target="_blank" rel="noopener"><code>koa-logger</code></a> 和 <a href="https://www.npmjs.com/package/koa-route" target="_blank" rel="noopener"><code>koa-route</code></a> 都是koa官方开发的“中间件”，分别用来打印日志和路由设置，路由设置稍后还会提到</li>
<li><code>fs</code> 和 <code>path</code> 都是 Node 的官方包，用来进行本地文件和路径相关的处理，辅助性质的</li>
<li><a href="https://www.npmjs.com/package/co-views" target="_blank" rel="noopener"><code>co-views</code></a> 是用来渲染模板的库，而 <code>render</code> 是它生成的实例，这个用法也跟传统用法不太一样，稍后会提及</li>
</ol>
<h3 id="Web-服务工作流"><a href="#Web-服务工作流" class="headerlink" title="Web 服务工作流"></a>Web 服务工作流</h3><pre><code>// workflow

app.use(logger())

app.use(route.get(&apos;/&apos;, list))
app.use(route.get(&apos;/page/:page&apos;, list))
app.use(route.get(&apos;/search/:keywords&apos;, search))
app.use(route.get(&apos;/search/:keywords/:page&apos;, search))

app.use(function *(next) {
  if (!this.path.match(/^\/assets\//)) {
    yield* next
    return
  }
  var path = __dirname + this.path
  var fstat = yield stat(path)

  if (fstat.isFile()) {
    this.type = extname(path)
    this.body = fs.createReadStream(path)
  }
})

app.use(function *(next) {
  if (this.needRendered) {
    this.body = yield render(this.templateView, {cache: false, data: this.templateModel})
  }
  yield* next
})


// utils

function stat(file) {
  return function (done) {
    fs.stat(file, done)
  }
}
</code></pre><p>这部分代码是用来规划服务器工作流的，从请求被接受到响应被发出，整个过程都在这段代码里一览无余。工作流设计的主要的用法是 <code>app.use(...)</code>。里面的参数其实就是一个 generator。</p>
<ol>
<li>首先是打开日志</li>
<li>然后是分发路由，这里可以看到，有首页、列表、搜索、搜索列表 4 种设计，分别对应到了各自的处理方，<code>list</code> 和 <code>search</code> 其实都是在利用 <code>lib/model</code> 在生成数据，准备给模板进行渲染。这里的原理也有特殊之处，稍后会看到</li>
<li>再看紧随其后的两个 <code>app.use</code>，分别是处理静态资源目录 <code>assets</code> 和对模板+数据进行渲染</li>
</ol>
<p>所以完整的工作流可以理解为：</p>
<ol>
<li>请求页面 (列表或搜索) -&gt; <code>logger</code> -&gt; 路由分发 -&gt; <code>list</code> 或  <code>search</code> -&gt; 模板渲染 -&gt; 回应</li>
<li>请求静态资源 -&gt; <code>logger</code> -&gt; 找到对应的 <code>assets</code> 文件 -&gt; 回应</li>
</ol>
<h3 id="function-和-yield-是啥？"><a href="#function-和-yield-是啥？" class="headerlink" title="function *() {} 和 yield 是啥？"></a><code>function *() {}</code> 和 <code>yield</code> 是啥？</h3><p>这个其实是 Koa 的精髓所在，在介绍它之前，我们先把 <code>list</code> 和 <code>search</code> 的代码也贴出来：</p>
<pre><code>// routes

function *list(page, next) {
  next = arguments[arguments.length - 1]
  this.templateView = &apos;page&apos;
  this.templateModel = yield model.list({page: page})
  this.needRendered = true
  yield *next
}

function *search(keywords, page, next) {
  next = arguments[arguments.length - 1]
  this.templateView = &apos;search&apos;
  this.templateModel = yield model.search({keywords: keywords, page: page})
  this.needRendered = true
  yield *next
}
</code></pre><p>大家会发现，首先 <code>app.use(...)</code>  和 <code>route.get(path, ...)</code> 传入的参数都是一种写得很像函数的东西，但不同之处是函数的写法是 <code>function foo() {...}</code>，而这里的写法多了一个星号，即 <code>function *foo() {}</code>。这种写法其实就是 ES6 里的 generator。而 <code>yield</code> 正是配合这个写法的一种语法。</p>
<p>有关 ES6 generator 的基础知识，建议大家来 @兔哥 的这个 <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">ES6 教程网页</a>来学习，这里不做原理方面的赘述。但我想说的是，由于 web 服务的处理本身就是“一层一层”的，并且有些处理是可以同步的，有些是只能异步的，我们不免要精心设计很多中间件并保障它的可扩展性，同时尽量简化异步操作的写法保障它的可读性。</p>
<p>有了 ES6 generator 和 <code>yield</code> 之后，我们的每一层中间件都可以从流程上看成一个以 <code>yield *next</code> 语句切分出来的 “三明治”：</p>
<pre><code>function *(next) {
  // 下一步之前的操作
  yield *next // 进行下一步
  // 所有逻辑处理完之后的补充操作
}
</code></pre><p>而且这个“下一步”是不介意是不是异步行为，都可以这样简单描述清楚的。</p>
<p><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="koa workflow"></p>
<p>后头看我们设计的整个工作流的实现：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/4e70cfbf5ae5069d6bb1a049cbb73e26241d34a7" alt="workflow"></p>
<p>我们这里的逻辑基于全部是出现在 <code>yield *next</code> 之前的，但是如果你需要在临发出响应之前做点什么，就可以写在其后面了</p>
<h3 id="co-views-的用法"><a href="#co-views-的用法" class="headerlink" title="co-views 的用法"></a><code>co-views</code> 的用法</h3><p><code>co-views</code> 其实是对通用模板引擎渲染平台 <a href="https://www.npmjs.com/package/consolidate" target="_blank" rel="noopener">consolidate</a> 的封装，consolidate 应该算是 express.js 时代非常重要的一个库，它支持包括 ejs, mustache, swig 等各种模板渲染并提供统一的 api 调用方法。根据对 <code>co-views</code> 源码的分析，它把 consolidate 统一的 api 又封装成了 <code>return function (done) {...}</code> 的形态，这样源代码中的 <code>yield render(view, model)</code> 就能够融入 generator 的逻辑之中。</p>
<p>值得一提的是，源代码中 <code>yield render(view, model)</code> 这里的 <code>model</code> 传入了一个 <code>{cache: false}</code> 的参数，这会意味着模板不会被缓存，每次修改模板文件之后，在不重启服务的情况下，刷新页面就可以看到最新的效果。这个选项是针对开发环境设置的，为了保障线上环境的运行性能和效率，这个选项应该是不需要的。</p>
<h3 id="lib-model-的用法"><a href="#lib-model-的用法" class="headerlink" title="lib/model 的用法"></a><code>lib/model</code> 的用法</h3><p>同上，我们在 <code>lib/model.js</code> 里封装的 <code>yield model.list({page: page})</code> 和 <code>yield model.search({keywords: keywords, page: page})</code> 也都会生成形如 <code>return function (done) {...}</code> 的返回值，以融入 generator 的逻辑之中。</p>
<h3 id="最后，监听端口"><a href="#最后，监听端口" class="headerlink" title="最后，监听端口"></a>最后，监听端口</h3><pre><code>// listen

app.listen(3000)
console.log(&apos;listening on port 3000&apos;)
</code></pre><p>That’s it</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在首次尝试用 generator 的方式编写 web 服务的时候，我自己一开始总会把 <code>yield</code> 的位置、<code>yield</code> 后面要不要加星号、<code>function</code> 后面要不要加星号、<code>app.use()</code> 的调用顺序这几件事情弄得乱糟糟的，可能还是对 generator 和 koa 的理解不够深入，不过逐渐写着写着，感受到了更多的爽和快感。到最后用如此简单的一个 js 文件完成了全部的功能和逻辑串联，还是觉得很兴奋的。大家如果感兴趣也可以搞来玩一玩，写点自己平时用得到用不到的小玩意儿体验一下：）</p>

</div>



<div id="comments">
  <h2>早期评论</h2>
  <ul>
  
    <li id="comment-102139" style="margin-left: 0em;">
      <p>
        <strong>
        summer
        
        </strong>
        <small>2015/06/21 11:09:22</small></p>
      我看koa的文档是使用 return yield next , 而博主则是使用 yield* next; return; 这两者有什么区别？
    </li>
  
    <li id="comment-102147" style="margin-left: 2em;">
      <p>
        <strong>
        zyEros
        
        </strong>
        <small>2015/06/22 12:03:54</small></p>
      从koa-compose的源码可以看到，每个app.use中的gen都执行了next = middleware[i].call(this,next),所以每个next其实是generator iterator，又因为在koa源码里面callback那个方法中使用了co.wrap(compose(wm))，所以两种写法都是可以的。
    </li>
  
    <li id="comment-102243" style="margin-left: 0em;">
      <p>
        <strong>
        <a href="http://fuxiaohei.me" target="_blank" title="傅小黑">傅小黑</a>
        
        </strong>
        <small>2015/06/22 06:41:05</small></p>
      *function和yield其实不是很喜欢，<br>
还是觉得下一代的async和await关键字描述，会更清晰
    </li>
  
    <li id="comment-108866" style="margin-left: 0em;">
      <p>
        <strong>
        face
        
        </strong>
        <small>2015/09/29 12:00:15</small></p>
      function stat(file) {<br>
  return function (done) {<br>
    fs.stat(file, done)<br>
  }<br>
}<br>
里的'done'是从哪里传进来的？
    </li>
  
    <li id="comment-111682" style="margin-left: 2em;">
      <p>
        <strong>
        <a href="http://jiongks.name/" target="_blank" title="囧克斯">囧克斯</a>
        
        </strong>
        <small>2016/01/06 12:41:15</small></p>
      算是一种JS技巧吧，koa代码里通篇都是这玩意儿……
    </li>
  
  </ul>
</div>

</div>

    <div id="footer">
      <a href="/">囧克斯</a>
      
      <a href="/atom.xml" title="rss_feed">文章 RSS</a>
      <br>
      我是百度统计：
      <script src="http://hm.baidu.com/h.js?a0a2372d4b7621d0bfe71f33c58a4bd8"></script>
    </div>
  </div>
  <script src="/js/script.js"></script>
</body>

</html>
