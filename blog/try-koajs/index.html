<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 用 Koa 写服务体验 · 囧克斯</title><meta name="description" content="用 Koa 写服务体验 - 勾三股四"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jinjiang.github.io/atom.xml" title="囧克斯"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">用 Koa 写服务体验</h1><div class="post-info">2015年6月21日</div><div class="post-content"><p><img src="http://img2.tbcdn.cn/L1/461/1/5682414ab4dc8dd1b4ff91b0b57f96947c1c1c11" alt="Koa"></p>
<p>晒一下自己用 <a href="http://koajs.com/" target="_blank" rel="noopener">Koa</a> next generation web framework for node.js 写的一个 web 服务</p>
<p>这个 web 服务主要是做内容的列表展示和搜索的 (可能说得比较抽象，但确实是 web 服务最常需要做的事情) 主要的文件一共就2个：</p>
<ul>
<li><code>app.js</code> 主程序</li>
<li><code>lib/model.js</code> 数据层</li>
</ul>
<p>其中 <code>model.js</code> 是和具体业务逻辑相关的，就不多介绍了，这也不是 Koa 的核心；而 <code>app.js</code> 的代码可以体现 Koa 的很多优点，也使得代码可以写得非常简练而去清晰——这是我自己都完全没有想到的事情</p>
<a id="more"></a>
<h3 id="加载资源和相关依赖库"><a href="#加载资源和相关依赖库" class="headerlink" title="加载资源和相关依赖库"></a>加载资源和相关依赖库</h3><pre><code>// resources

var koa = require(&apos;koa&apos;)
var app = koa()

var logger = require(&apos;koa-logger&apos;)
var route = require(&apos;koa-route&apos;)

var fs = require(&apos;fs&apos;)
var path = require(&apos;path&apos;)
var extname = path.extname

var views = require(&apos;co-views&apos;)
var render = views(&apos;./views&apos;, {
  map: { html: &apos;ejs&apos; }
})

var model = require(&apos;./lib/model&apos;)
</code></pre><p>其中：</p>
<ol>
<li><code>koa</code> 是最核心的库，<code>app</code> 是 <code>koa</code> 生成的 web 服务主程序</li>
<li><a href="https://www.npmjs.com/package/koa-logger" target="_blank" rel="noopener"><code>koa-logger</code></a> 和 <a href="https://www.npmjs.com/package/koa-route" target="_blank" rel="noopener"><code>koa-route</code></a> 都是koa官方开发的“中间件”，分别用来打印日志和路由设置，路由设置稍后还会提到</li>
<li><code>fs</code> 和 <code>path</code> 都是 Node 的官方包，用来进行本地文件和路径相关的处理，辅助性质的</li>
<li><a href="https://www.npmjs.com/package/co-views" target="_blank" rel="noopener"><code>co-views</code></a> 是用来渲染模板的库，而 <code>render</code> 是它生成的实例，这个用法也跟传统用法不太一样，稍后会提及</li>
</ol>
<h3 id="Web-服务工作流"><a href="#Web-服务工作流" class="headerlink" title="Web 服务工作流"></a>Web 服务工作流</h3><pre><code>// workflow

app.use(logger())

app.use(route.get(&apos;/&apos;, list))
app.use(route.get(&apos;/page/:page&apos;, list))
app.use(route.get(&apos;/search/:keywords&apos;, search))
app.use(route.get(&apos;/search/:keywords/:page&apos;, search))

app.use(function *(next) {
  if (!this.path.match(/^\/assets\//)) {
    yield* next
    return
  }
  var path = __dirname + this.path
  var fstat = yield stat(path)

  if (fstat.isFile()) {
    this.type = extname(path)
    this.body = fs.createReadStream(path)
  }
})

app.use(function *(next) {
  if (this.needRendered) {
    this.body = yield render(this.templateView, {cache: false, data: this.templateModel})
  }
  yield* next
})


// utils

function stat(file) {
  return function (done) {
    fs.stat(file, done)
  }
}
</code></pre><p>这部分代码是用来规划服务器工作流的，从请求被接受到响应被发出，整个过程都在这段代码里一览无余。工作流设计的主要的用法是 <code>app.use(...)</code>。里面的参数其实就是一个 generator。</p>
<ol>
<li>首先是打开日志</li>
<li>然后是分发路由，这里可以看到，有首页、列表、搜索、搜索列表 4 种设计，分别对应到了各自的处理方，<code>list</code> 和 <code>search</code> 其实都是在利用 <code>lib/model</code> 在生成数据，准备给模板进行渲染。这里的原理也有特殊之处，稍后会看到</li>
<li>再看紧随其后的两个 <code>app.use</code>，分别是处理静态资源目录 <code>assets</code> 和对模板+数据进行渲染</li>
</ol>
<p>所以完整的工作流可以理解为：</p>
<ol>
<li>请求页面 (列表或搜索) -&gt; <code>logger</code> -&gt; 路由分发 -&gt; <code>list</code> 或  <code>search</code> -&gt; 模板渲染 -&gt; 回应</li>
<li>请求静态资源 -&gt; <code>logger</code> -&gt; 找到对应的 <code>assets</code> 文件 -&gt; 回应</li>
</ol>
<h3 id="function-和-yield-是啥？"><a href="#function-和-yield-是啥？" class="headerlink" title="function *() {} 和 yield 是啥？"></a><code>function *() {}</code> 和 <code>yield</code> 是啥？</h3><p>这个其实是 Koa 的精髓所在，在介绍它之前，我们先把 <code>list</code> 和 <code>search</code> 的代码也贴出来：</p>
<pre><code>// routes

function *list(page, next) {
  next = arguments[arguments.length - 1]
  this.templateView = &apos;page&apos;
  this.templateModel = yield model.list({page: page})
  this.needRendered = true
  yield *next
}

function *search(keywords, page, next) {
  next = arguments[arguments.length - 1]
  this.templateView = &apos;search&apos;
  this.templateModel = yield model.search({keywords: keywords, page: page})
  this.needRendered = true
  yield *next
}
</code></pre><p>大家会发现，首先 <code>app.use(...)</code>  和 <code>route.get(path, ...)</code> 传入的参数都是一种写得很像函数的东西，但不同之处是函数的写法是 <code>function foo() {...}</code>，而这里的写法多了一个星号，即 <code>function *foo() {}</code>。这种写法其实就是 ES6 里的 generator。而 <code>yield</code> 正是配合这个写法的一种语法。</p>
<p>有关 ES6 generator 的基础知识，建议大家来 @兔哥 的这个 <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">ES6 教程网页</a>来学习，这里不做原理方面的赘述。但我想说的是，由于 web 服务的处理本身就是“一层一层”的，并且有些处理是可以同步的，有些是只能异步的，我们不免要精心设计很多中间件并保障它的可扩展性，同时尽量简化异步操作的写法保障它的可读性。</p>
<p>有了 ES6 generator 和 <code>yield</code> 之后，我们的每一层中间件都可以从流程上看成一个以 <code>yield *next</code> 语句切分出来的 “三明治”：</p>
<pre><code>function *(next) {
  // 下一步之前的操作
  yield *next // 进行下一步
  // 所有逻辑处理完之后的补充操作
}
</code></pre><p>而且这个“下一步”是不介意是不是异步行为，都可以这样简单描述清楚的。</p>
<p><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="koa workflow"></p>
<p>后头看我们设计的整个工作流的实现：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/4e70cfbf5ae5069d6bb1a049cbb73e26241d34a7" alt="workflow"></p>
<p>我们这里的逻辑基于全部是出现在 <code>yield *next</code> 之前的，但是如果你需要在临发出响应之前做点什么，就可以写在其后面了</p>
<h3 id="co-views-的用法"><a href="#co-views-的用法" class="headerlink" title="co-views 的用法"></a><code>co-views</code> 的用法</h3><p><code>co-views</code> 其实是对通用模板引擎渲染平台 <a href="https://www.npmjs.com/package/consolidate" target="_blank" rel="noopener">consolidate</a> 的封装，consolidate 应该算是 express.js 时代非常重要的一个库，它支持包括 ejs, mustache, swig 等各种模板渲染并提供统一的 api 调用方法。根据对 <code>co-views</code> 源码的分析，它把 consolidate 统一的 api 又封装成了 <code>return function (done) {...}</code> 的形态，这样源代码中的 <code>yield render(view, model)</code> 就能够融入 generator 的逻辑之中。</p>
<p>值得一提的是，源代码中 <code>yield render(view, model)</code> 这里的 <code>model</code> 传入了一个 <code>{cache: false}</code> 的参数，这会意味着模板不会被缓存，每次修改模板文件之后，在不重启服务的情况下，刷新页面就可以看到最新的效果。这个选项是针对开发环境设置的，为了保障线上环境的运行性能和效率，这个选项应该是不需要的。</p>
<h3 id="lib-model-的用法"><a href="#lib-model-的用法" class="headerlink" title="lib/model 的用法"></a><code>lib/model</code> 的用法</h3><p>同上，我们在 <code>lib/model.js</code> 里封装的 <code>yield model.list({page: page})</code> 和 <code>yield model.search({keywords: keywords, page: page})</code> 也都会生成形如 <code>return function (done) {...}</code> 的返回值，以融入 generator 的逻辑之中。</p>
<h3 id="最后，监听端口"><a href="#最后，监听端口" class="headerlink" title="最后，监听端口"></a>最后，监听端口</h3><pre><code>// listen

app.listen(3000)
console.log(&apos;listening on port 3000&apos;)
</code></pre><p>That’s it</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在首次尝试用 generator 的方式编写 web 服务的时候，我自己一开始总会把 <code>yield</code> 的位置、<code>yield</code> 后面要不要加星号、<code>function</code> 后面要不要加星号、<code>app.use()</code> 的调用顺序这几件事情弄得乱糟糟的，可能还是对 generator 和 koa 的理解不够深入，不过逐渐写着写着，感受到了更多的爽和快感。到最后用如此简单的一个 js 文件完成了全部的功能和逻辑串联，还是觉得很兴奋的。大家如果感兴趣也可以搞来玩一玩，写点自己平时用得到用不到的小玩意儿体验一下：）</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/just-vue/" class="prev">PREV</a><a href="/blog/config-in-webcomponents/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://jinjiang.github.io">勾三股四</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>