<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [翻译] JSLint 文档 · 囧克斯</title><meta name="description" content="[翻译] JSLint 文档 - 勾三股四"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jinjiang.github.io/atom.xml" title="囧克斯"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[翻译] JSLint 文档</h1><div class="post-info">2013年2月17日</div><div class="post-content"><p>原文地址：<a href="http://www.jslint.com/lint.html" target="_blank" rel="noopener">http://www.jslint.com/lint.html</a></p>
<h3 id="什么是JSLint？"><a href="#什么是JSLint？" class="headerlink" title="什么是JSLint？"></a>什么是<code>JSLint</code>？</h3><p><code>JSLint</code> 是一个用来查找各种 JavaScript 程序中的问题的 JavaScript 程序。它是一个代码之类工具。</p>
<p>在<a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.html" target="_blank" rel="noopener">早些年</a>的 <a href="http://en.wikipedia.org/wiki/C_programming_language" target="_blank" rel="noopener">C 语言</a>中，有些程序的常见错误是主流的编译器无法抓住的。所以出现了一个名叫 <a href="http://en.wikipedia.org/wiki/Lint_programming_tool" target="_blank" rel="noopener"><code>lint</code></a> 的附带程序，可以通过搜索源文件寻找错误。</p>
<p>随着语言的成熟，其定义的健壮性足以消除一些不安因素，编译器也在问题警告方面越做越好，<code>lint</code> 也不再需要了。</p>
<p><a href="http://javascript.crockford.com/" target="_blank" rel="noopener">JavaScript</a> 是一个年轻的语言。它原本只是用在网页上完成一些无需劳驾 Java 的小任务。但 JavaScript 是一个强大得惊人的语言，现在它已经在大项目中派上用场了。当项目变得复杂之后，之前从易用角度出发的语言特性就带来了一些麻烦。这是一个为 JavaScript 而生的 <code>lint</code> 呼之欲出：它就是 <code>JSLint</code>，一个检查 JavaScript 语法、判断 JavaScript 语法有效性的工具。</p>
<p><code>JSLint</code> 会拿来一段 JavaScript 源代码并对其进行检索。一旦发现问题，它就会返回一则消息，用来描述这个问题以及源代码中的大概位置。发现的问题不一定是，但通常是语法上的错误。<code>JSLint</code> 通过一些代码规范来杜绝结构性的问题。这并不证明你的程序是正确的，只是提供另一种发现问题的眼光。</p>
<p><code>JSLint</code> 定义了一个专业的 JavaScript 的子集，它比 <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">ECMAScript 标准第三版</a>的定义更严格，和 <a href="http://javascript.crockford.com/code.html" target="_blank" rel="noopener">JavaScript 编码规范</a>中的建议相对应。</p>
<p>JavaScript 是一个粗中有细的语言，它比你想象中的更好。<code>JSLint</code> 帮助你回避很多问题，在这个更好的语言中撰写程序。<code>JSLint</code> 会拒绝一些浏览器支持的程序，因为浏览器并不关心代码的质量。你应该接受 <code>JSLint</code> 的所有建议。</p>
<p><code>JSLint</code> 在 JavaScript 源代码、HTML 源代码、CSS 源代码或 <a href="http://www.json.org/" target="_blank" rel="noopener">JSON</a> 文本中都可以运行。<a id="more"></a></p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>JavaScript 的最大问题就是其依赖的全局变量，特别隐含的全局变量。如果一个变量没有被显性的声明 (通常是通过 <code>var</code> 语句)，则 JavaScript 会假定这个变量是全局变量。这会掩盖拼写错误等其它问题。</p>
<p><code>JSLint</code> 希望所有的变量和函数都要在使用或调用之前被声明。这样我们就可以探测隐含着的全局变量。同时，这也让程序的可读性增强了。</p>
<p>有的时候一个文件会依赖于在别处定义好的全局变量或全局函数。这时你可以通过一个 <code>var</code> 语句让 <code>JSLint</code> 识别该程序依赖的这些全局函数和对象。</p>
<p>一个全局声明大概如下所示：</p>
<pre><code>var getElementByAttribute, breakCycles, hanoi;
</code></pre><p>该声明应该出现在靠近文件最上方的位置，且必须出现在使用这些变量之前。</p>
<p>同时，我们有必要在一个变量被赋值之前通过 <code>var</code> 语句对其进行声明。</p>
<p><code>JSLint</code> 同样可以识别一段 <code>/*global*/</code> 指令，该指令可以为 <code>JSLint</code> 注明在该文件中使用但在其它文件中定义好的变量。该指令可以包含一串变量名，用逗号隔开。每个名字可以跟随一个可选的冒号以及 <code>true</code> 或 <code>false</code>，<code>true</code> 表示该变量可以被该文件赋值，而 <code>false</code> 则表示该变量不能被赋值 (这是默认行为)。在函数作用域也是如此。</p>
<p>有些全局变量可以被你预定义。选择<em>假设为浏览器</em> (<code>browser</code>) 选项可以预定义浏览器提供的标准的全局属性，比如 <code>document</code> 和 <code>addEventListener</code>。它等同于：</p>
<pre><code>/*global clearInterval: false, clearTimeout: false, document: false, event: false, frames: false, history: false, Image: false, location: false, name: false, navigator: false, Option: false, parent: false, screen: false, setInterval: false, setTimeout: false, window: false, XMLHttpRequest: false */
</code></pre><p>选择<em>假设为 Node.js</em> (<code>node</code>) 选项可以预定义 Node.js 环境下的全局变量。它等同于：</p>
<pre><code>/*global Buffer: false, clearInterval: false, clearTimeout: false, console: false, exports: false, global: false, module: false, process: false, querystring: false, require: false, setInterval: false, setTimeout: false, __filename: false, __dirname: false */
</code></pre><p>选择<em>假设为 Rhino</em> (<code>rhino</code>) 选项可以预定义 Rhino 环境下的全局属性。它等同于：</p>
<pre><code>/*global defineClass: false, deserialize: false, gc: false, help: false, load: false, loadClass: false, print: false, quit: false, readFile: false, readUrl: false, runCommand: false, seal: false, serialize: false, spawn: false, sync: false, toint32: false, version: false */
</code></pre><p>选择<em>假设为 Windows</em> (<code>windows</code>) 选项可以预定义 Microsoft Windows 提供的全局属性。它等同于：</p>
<pre><code>/*global ActiveXObject: false, CScript: false, Debug: false, Enumerator: false, System: false, VBArray: false, WScript: false, WSH: false */
</code></pre><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>JavaScript 使用近似于 C 语言的语法，它要求使用分号来分割确定的语句。JavaScript 试图通过一个自动插入分号的机制让这些分号变得可有可无。这是比较危险的，因为它可以掩盖你的错误。</p>
<p>和 C 一样，JavaScript 有 <code>++</code> 和 <code>--</code> 和 <code>(</code> 操作符，这些操作符可以作为前缀或后缀。分号可以用来消除这里的二义性。</p>
<p>在 JavaScript 中，一个折行可以是一个空格，也可以当做分号使用，两者容易产生混淆。</p>
<p><code>JSLint</code> 希望除了 <code>for</code>、<code>function</code>、<code>if</code>、<code>switch</code>、<code>try</code>和<code>while</code>，每个语句都以 <code>;</code> 结尾。同时 <code>JSLint</code> 不希望看到没有必要的分号或空白语句。</p>
<h3 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h3><p>我们可以用逗号操作符写出极度巧妙的表达式。同时也可以掩盖一些程序上的错误。</p>
<p><code>JSLint</code> 希望逗号只用来当做分隔符，而不是操作符 (<code>for</code> 语句中的初始化部分和自增部分除外)。数组直接量里不希望有被省略的元素，多余的逗号不应该被使用，逗号不应该出现在数组直接量或对象直接量的最后一个元素的后面，因为一些浏览器无法正常识别。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在很多语言中，每个块都产生一个作用域，块内产生的变量在块外是看不到的。</p>
<p>在 JavaScript 中，块并不产生新的作用域，只有函数作用域。在一个函数中任意位置声明的变量都在整个函数中可见。JavaScript 的块混淆了有经验的程序员，并导致了错误的出现，因为用相似的语法做了一个错误的承诺。</p>
<p><code>JSLint</code> 希望 <code>function</code>、<code>if</code>、<code>switch</code>、<code>while</code>、<code>for</code>、<code>do</code> 和 <code>try</code> 语句之外不要产生其它块。</p>
<p>在有块级作用域的语言里，通常都推荐变量声明在第一次使用的地方。但是因为 JavaScript 没有块级作用域，所以明智的选择就是在函数的最顶端声明所有的函数变量。这里推荐每个函数用单一的一个 <code>var</code> 语句完成变量声明。这个要求可以通过 <code>vars</code> 选项取消掉。</p>
<h3 id="必要的块"><a href="#必要的块" class="headerlink" title="必要的块"></a>必要的块</h3><p><code>JSLint</code> 希望 <code>if</code>、<code>while</code>、<code>do</code> 和 <code>for</code> 语句都由块生成，<code>{</code> 也就是说，语句是被大括号包住的 <code>}</code>。</p>
<p>JavaScript 允许一个 <code>if</code> 语句这样书写：</p>
<pre>if (<i>condition</i>) <i>statement</i>;</pre>

<p>这个格式是公认的：当很多程序员都基于相同的代码工作时，会给整个项目带来很多错误。这也是为什么 <code>JSLint</code> 希望如下使用块：</p>
<pre>if (<i>condition</i>) { <i>statement</i>; }</pre>

<p>经验告诉我们这个格式更保险一些。</p>
<h3 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h3><p>我们希望一个表达式语句是一个赋值或一个函数/方法调用或 <code>delete</code>。其它表达式语句都可能导致错误。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a><code>for</code> <code>in</code></h3><p><code>for</code> <code>in</code> 语句允许在一个对象的所有属性名内进行循环。<a href="http://yuiblog.com/blog/2006/09/26/for-in-intrigue/" target="_blank" rel="noopener">不幸的是，这样的循环也会覆盖到其原型链中所有被继承而来的属性。</a>其副作用就是当我们只关心数据的时候，它连方法函数也会处理一遍。如果此时该程序没有任何预防措施，那么就会导致失败。</p>
<p>每个 <code>for</code> <code>in</code> 语句的主体部分都应该包裹一个起过滤效果的 <code>if</code> 语句。该语句可以选择特殊类型或范围的值、或排除函数类型的属性、或排除原型的属性。比如：</p>
<pre><code>for (name in object) { if (object.hasOwnProperty(name)) { .... } }
</code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h3><p>一个 <code>switch</code> 语句中<a href="http://yuiblog.com/blog/2007/04/25/id-rather-switch-than-fight/" target="_blank" rel="noopener">常见的错误</a>就是忘记在每个条件的结尾写上 <code>break</code> 语句，导致程序没有及时跳走。<code>JSLint</code> 希望语句的下一个 <code>case</code> 之前或 <code>default</code> 之前必须有下面三个当中的一个：<code>break</code>、<code>return</code>、<code>throw</code>。</p>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h3><p>JavaScript 允许 <code>var</code> 在一个函数内的任何位置完成定义。<code>JSLint</code> 的要求则会更严格一些。</p>
<p><code>JSLint</code> 希望一个 <code>var</code> 只被声明一次，并且是在使用之前被声明。</p>
<p><code>JSLint</code> 希望一个 <code>function</code> 在使用之前被声明。</p>
<p><code>JSLint</code> 希望函数的参数不要被声明为变量。</p>
<p><code>JSLint</code> 不希望 <code>arguments</code> 数组被声明为 <code>var</code>。</p>
<p><code>JSLint</code> 不希望一个变量被定义在块中。这是因为 JavaScript 的块并不具有块级作用域。这会造成意料之外的结果。把所有的变量都定义在函数的最顶部。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h3><p><code>with</code> 语句的初衷是提供一个访问对象嵌套属性的简写方式。不幸的是，当我们设置新属性时这个行为<a href="http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful/" target="_blank" rel="noopener">非常糟糕</a>。永远不要使用 <code>with</code> 语句。请用一个 <code>var</code> 替代之。</p>
<h3 id=""><a href="#" class="headerlink" title="="></a><code>=</code></h3><p><code>JSLint</code> 不希望看到 <code>if</code>、<code>for</code>、<code>while</code> 或 <code>do</code> 语句的条件判断中出现赋值语句。这是因为似乎：</p>
<pre><code>if (a = b) { ... }
</code></pre><p>的本意是：</p>
<pre><code>if (a == b) { ... }
</code></pre><p>当我们难以从常用语句中察觉出明显的错误时，是很难把程序写对的。</p>
<h3 id="和"><a href="#和" class="headerlink" title="== 和 !="></a><code>==</code> 和 <code>!=</code></h3><p><code>==</code> 和 <code>!=</code> 操作会在比较之前做类型转换。这是不提倡的，因为它导致 <code>&#39; \t\r\n&#39; == 0</code> 的结果是 <code>true</code>。这会掩盖一些类型错误。<code>JSLint</code> 无法依赖 <code>==</code> 进行判断，所以最好别再使用  <code>==</code> 和 <code>!=</code> 了，以后都用更可靠的 <code>===</code> 和 <code>!==</code> 操作替代之。</p>
<p>如果你只是在乎一个值是<em>真的</em>还是<em>假的</em>，那么可以使用简写方式，比如把：</p>
<pre><code>(foo != 0)
</code></pre><p>替换为：</p>
<pre><code>(foo)
</code></pre><p>而将：</p>
<pre><code>(foo == 0)
</code></pre><p>替换为：</p>
<pre><code>(!foo)
</code></pre><p>我们有一个 <code>eqeq</code> 选项，允许使用 <code>==</code> 和 <code>!=</code>。</p>
<h3 id="标签-labels"><a href="#标签-labels" class="headerlink" title="标签 (labels)"></a>标签 (labels)</h3><p>JavaScript 允许任何语句拥有标签，标签拥有各自的命名空间。<code>JSLint</code> 的要求会更严格。</p>
<p><code>JSLint</code> 希望标签只出现在响应 <code>break</code>、<code>swtich</code>、<code>while</code>、<code>do</code> 和 <code>for</code> 的语句上。<code>JSLint</code> 希望标签可以同变量和参数区分开来。</p>
<h3 id="无法到达的代码"><a href="#无法到达的代码" class="headerlink" title="无法到达的代码"></a>无法到达的代码</h3><p><code>JSLint</code> 希望一个 <code>return</code>、<code>break</code>、<code>continue</code> 或 <code>throw</code> 语句后面都会跟着一个 <code>}</code> 或 <code>case</code> 或 <code>default</code>。</p>
<h3 id="混乱的加号减号"><a href="#混乱的加号减号" class="headerlink" title="混乱的加号减号"></a>混乱的加号减号</h3><p><code>JSLint</code> 希望 <code>+</code> 不会紧跟着 <code>+</code> 或 <code>++</code>，而 <code>-</code> 不会紧跟着 <code>-</code> 或 <code>--</code>。少写一个空格就会把 <code>+ +</code> 变成 <code>++</code>，这种错误是很难被发现的。为了避免混乱，请善用括号。</p>
<h3 id="和-1"><a href="#和-1" class="headerlink" title="++ 和 --"></a><code>++</code> 和 <code>--</code></h3><p>自增操作符 <code>++</code> 和自减操作符 <code>--</code> 是公认的会鼓励过度使用技巧而导致糟糕的代码。它们是导致病毒和安全威胁的错误构建。同样的，乱用前自增和后自增会产生 off-by-one 的错误，排查这样的错误是极为困难的。我们有一个 <code>plusplus</code> 选项来允许使用这些操作符。</p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>JavaScript 没有整数类型 (*)，但是其具备位操作符。位操作符会先把操作对象由浮点数转换回整数，所以这样的位操作效率远不及 C 或其它语言。位操作符极少用在浏览器应用里。与逻辑操作符的相似性也会掩盖一些程序的错误。<code>bitwise</code> 选项允许使用 <code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code>、<code>~</code>、<code>&amp;</code>、<code>|</code> 这些操作符。</p>
<h3 id="eval-是魔鬼"><a href="#eval-是魔鬼" class="headerlink" title="eval 是魔鬼"></a><code>eval</code> 是魔鬼</h3><p><code>eval</code> 函数 (及其相似的 <code>Function</code>、<code>setTimeout</code> 和 <code>setInterval</code>) 提供了 JavaScript 编译器的访问形式。这在一些情况下是有必要的，但是在大多数情况下它代表了相当糟糕的代码。<code>eval</code> 函数是 JavaScript 最不应该被使用的特性。</p>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a><code>void</code></h3><p>在大多数近似于 C 的语言中，<code>void</code> 是一个类型。在 JavaScript 中，<code>void</code> 是一个前缀操作符，它总是返回 <code>undefined</code>。<code>JSLint</code> 不希望看到 <code>void</code> 因为它具有迷惑性且没有实质的用处。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式写起来既简洁又神秘。<code>JSLint</code> 会检测一些可能导致可移植性问题的问题。同时会推荐把具有视觉混淆性质的字符全部转义。</p>
<p>JavaScript 语法中，正则表达式直接量会多写一对 <code>/</code> 字符。为了避免混淆，<code>JSLint</code> 希望一个正则表达式字面量的开头是一个 <code>(</code> 或 <code>=</code> 或 <code>:</code> 或 <code>,</code> 字符。</p>
<h3 id="构造函数和-new"><a href="#构造函数和-new" class="headerlink" title="构造函数和 new"></a>构造函数和 <code>new</code></h3><p>构造函数是设计为通过 <code>new</code> 前缀使用的函数。<code>new</code> 前缀基于函数的 <code>prototype</code> 创建一个新的对象，并把函数隐性提供的 <code>this</code> 参数绑定到那个对象。如果你忽略了 <code>new</code> 前缀的使用，则不会有新的对象被创建，而 <code>this</code> 则会绑定到全局对象上。这是<a href="http://yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/" target="_blank" rel="noopener">非常严重的错误</a>。</p>
<p><code>JSLint</code> 强制规范构造函数的函数名大写开头。<code>JSLint</code>不希望看到一个函数调用的函数名是大写开头但没有 <code>new</code> 前缀。<code>JSLint</code> 也不希望看到 <code>new</code> 前缀用在一个函数名不是大写开头的函数上。这一要求可以通过 <code>newcap</code> 选项关掉。</p>
<p><code>JSLint</code> 不希望看到 <code>new Number</code>、<code>new String</code>、<code>new Boolean</code> 的包裹形式。</p>
<p><code>JSLint</code> 不希望看到 <code>new Object</code>，用 <code>{}</code> 替换之。</p>
<p><code>JSLint</code> 不希望看到 <code>new Array</code>，用 <code>[]</code> 替换之。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>因为 JavaScript 是个弱类型动态对象语言，所以不太可能在编译的时候判定一个属性名是否拼写正确。<code>JSLint</code> 在这方面提供了一些帮助。</p>
<p>在其报告的最底端，<code>JSLint</code> 显示了一个 <code>/*properties*/</code> 指令。它包含了一些名称和字符串直接量，它们是所有使用过的点标记、下标标记和对象直接量中用来命名对象属性的。你可以查阅这个列表来找到拼错的词。这是个比较简单的办法。</p>
<p>你还可以复制 <code>/*properties*/</code> 指令到你的脚本文件的顶端。<code>JSLint</code> 会根据这个列表检查所有的属性名。这样，你就可以使用 <code>JSLint</code> 检查拼写错误了。</p>
<p>比如：</p>
<pre><code>/*properties charAt, slice */
</code></pre><h3 id="不安全字符"><a href="#不安全字符" class="headerlink" title="不安全字符"></a>不安全字符</h3><p>有一些字符是不同的浏览器显示起来不一致的，在放入字符串之前必须先转义。</p>
<pre><code>\u0000-\u001f \u007f-\u009f \u00ad \u0600-\u0604 \u070f \u17b4 \u17b5 \u200c-\u200f \u2028-\u202f \u2060-\u206f \ufeff \ufff0-\uffff
</code></pre><h3 id="不检查的内容"><a href="#不检查的内容" class="headerlink" title="不检查的内容"></a>不检查的内容</h3><p><code>JSLint</code> 不会做流程分析，也不会判断变量在使用之前是否已经被赋值。这是因为变量都有默认值 (<code>undefined</code>)，很多应用本身就是这样处理的。</p>
<p><code>JSLint</code> 不会做任何类型的全局分析，不会尝试判断伴随 <code>new</code> 使用的函数是真正的构造函数 (只是遵循大小写规范)，不会检查属性名拼写是否正确 (只是针对 <code>/*properties*/</code> 指令进行匹配)。</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><code>JSLint</code> 可以处理 HTML 文本。它可以找到包含在 <code>&lt;script&gt;</code> … <code>&lt;/script&gt;</code> 标签中的 JavaScript 内容。也可以通过 JavaScript 找到 HTML 内容中公认的问题：</p>
<ul>
<li>所有的标签必须小写。</li>
<li>所有的标签必须闭合 (比如 <code>&lt;/p&gt;</code>)。</li>
<li>所有的标签必须正确的嵌套</li>
<li>必须用实体 <code>&amp;lt;</code> 表示字面量 <code>&gt;</code>。</li>
</ul>
<p><code>JSLint</code> 比 XHTML 的要求要低，但是比主流浏览器的要求要严格。</p>
<p><code>JSLint</code> 也会检查 <code>&#39;&lt;/&#39;</code> 在字符串字面量的出现情况，你应该用 <code>&#39;&lt;\/&#39;</code> 替换之。额外的反斜杠会被 JavaScript 编译器忽略掉，但 HTML 解析器不会。类似的技巧都不是必要的，但就是这样。</p>
<p>这里有一个 <code>fragment</code> 选项，用来检查一个合格的 HTML 片段。如果 <code>adsafe</code> 选项也选用，则片段必须是一个遵守 <a href="http://www.adsafe.org/" target="_blank" rel="noopener">ADSafe</a> widget 规则的 <code>&lt;div&gt;</code>。</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><code>JSLint</code> 可以检查 CSS 文件。它检查 CSS 文件的第一行是不是：</p>
<pre><code>@charset &quot;UTF-8&quot;;
</code></pre><p>这个特性是试验性的。请把任何问题或束缚报告出来。这里有一个 <code>css</code> 选项，可以容忍一些非标准的使用习惯。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><code>JSLint</code> 提供了很多选项，它们控制了其操作和敏感度。在网页版中，选项是可以通过复选框进行勾选的。</p>
<p>我们还提供了通过构造 <code>/*jslint*/</code> 指令和 <code>/*properties*/</code> 指令的方式进行辅助。</p>
<p>当 <code>JSLint</code> 被当做函数调用时，它接受一个 <code>option</code> 对象参数，这个参数允许你判定你可接受的 JavaScript 子集。网页版的 <code>JSLint</code> 在 <a href="http://www.jslint.com" target="_blank" rel="noopener">http://www.JSLint.com</a>，就是这样工作的。</p>
<p>选项还可以在 <code>/*jslint*/</code> 指令中被定义：</p>
<pre><code>/*jslint nomen: true, debug: true, evil: false, vars: true*/
</code></pre><p>选项指令起始于 ‘/<em>jslint’。注意 <code>j</code> 前面没有空格。本规范包含了一系列的键值对，这些键是 <code>JSLint</code> 的选项，值是 <code>true</code> 或 <code>false</code>。<code>indent</code> 选项可以取一个数字。一个 `/</em>jslint*/<code>指令优先于</code>option` 对象。指令遵照函数作用域。</p>
<p>(表格略，详见：<a href="http://www.jslint.com/lint.html#options" target="_blank" rel="noopener">http://www.jslint.com/lint.html#options</a>)</p>
<h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p>如果 <code>JSLint</code> 可以完成检查，那么它会生成一个函数报告。其列出下面每个函数：</p>
<ul>
<li>起始行号。</li>
<li>名称。如果是匿名函数，<code>JSLint</code> 会“猜”出这个名称。</li>
<li>参数。</li>
<li><em>Closure</em>：被声明的变量和参数之中，被子函数使用的部分。</li>
<li><em>Variables</em>：被声明并只在该函数中使用的变量。</li>
<li><em>Exceptions</em>：被 try 语句声明的变量。</li>
<li><em>Unused</em>：被声明但从未在该函数中使用的变量。这可能意味着一个错误。</li>
<li><em>Outer</em>：被其它函数声明且在该函数中使用的变量。</li>
<li><em>Global</em>：在该函数中使用的全局变量。把这个用量降到最少。</li>
<li><em>Label</em>：该函数中使用的语句标记。</li>
</ul>
<p>报告还会包含一个使用过的属性名列表。这里是<a href="http://www.jslint.com/msgs.html" target="_blank" rel="noopener"><code>JSLint</code>的消息列表</a>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/code-editor-survay/" class="prev">PREV</a><a href="/blog/my-6th-year-with-maxthon/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://jinjiang.github.io">勾三股四</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>