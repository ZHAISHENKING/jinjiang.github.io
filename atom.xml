<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>囧克斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jinjiang.github.io/"/>
  <updated>2018-04-03T03:03:34.000Z</updated>
  <id>https://jinjiang.github.io/</id>
  
  <author>
    <name>勾三股四</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第四届 CSSConf CN 见闻</title>
    <link href="https://jinjiang.github.io//blog/cssconf-cn-4/"/>
    <id>https://jinjiang.github.io//blog/cssconf-cn-4/</id>
    <published>2018-04-03T02:49:26.000Z</published>
    <updated>2018-04-03T03:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周末作为一名分享者参加了 <a href="https://css.w3ctech.com/" target="_blank" rel="noopener">CSSConf CN</a>，在厦门。</p><p>其实除了自己的分享内容，这次我是带着很明确的目的参会的，因为有两个主题我特别关注，就是：</p><ul><li>第一个：响应式的组件</li><li>第三个：从 API 的角度看组件的 CSS</li></ul><p>(两个分享的标题都被我稍微“演绎”了一下)</p><p>这两件事都是自己工作上正在特别关注的事情，一方面，我们很少从 API 的角度去理解一个组件的 CSS 该如何组织和管理，所以这个标题就特别吸引我，另一方面响应式组件的分享者是来自新加坡的前端工程师 Zell (我个人一直觉得国内的响应式都是在瞎搞，看了很多周围团队都没有认真做这件事，甚至不相信响应式的价值，从设计师到工程师)，因此非常珍惜这个机会能近距离学习一些国外的同行们是怎么看待和实践响应式的。</p><p>所以尽管我们团队的差旅经费已经用完了，还是决定自费来厦门近距离交流一下。</p><p>现在证明这次真的不虚此行。</p><p>当然参加这种线下活动，“面基”的目的是一定有的……恩，这个不值一提。</p><h3 id="响应式组件"><a href="#响应式组件" class="headerlink" title="响应式组件"></a>响应式组件</h3><p>在谈这次分享内容给我的收获之前，我想说，实际上我不只是从几十分钟的分享中学习了响应式组件的东西。我这次去厦门的行程特地提前了两天，周四就到厦门了，就是希望能多一些分享的准备和现场交流。正好 Zell 也到的比较早，于是乎我在周末的会议之前就跟 Zell 聊了很多。真的是很难得的机会。</p><p>回到分享的内容，我听过 Zell 的分享之后简单整理了一些要点：</p><ol><li>Proportional scaling：让所有的组件成比例<ul><li>注意字号：<code>font-size</code> 尽量使用 <code>em</code> 单位，而不是如 <code>px</code> 的绝对单位</li><li>注意视口/窗口大小 (viewport)：尽量使用 <code>vw</code>、<code>vh</code>、<code>vmin</code>、<code>vmax</code> 单位，必要的时候可以配合 <code>calc()</code></li></ul></li><li>Responsive scaling：处理好响应式的断点<ul><li>善用 media query</li><li>尽可能使用 <code>min-width</code>，以小屏幕为基础</li><li>必要的时候使用 <code>min-width</code> 和 <code>max-width</code> 的交集，避免样式间不必要的相互干扰</li></ul></li><li>Modular scaling：像乐高一样拼合模块时的注意事项<ul><li>不要在子元素上直接设置外边距</li><li>取而代之的是在父元素上整体设置每个子元素的边距<ul><li>巧用 <code>+</code> 选择器处理最后一个元素多余的边距</li></ul></li><li>在需要对其的地方使用 <code>rem</code> 作为边距的单位以避免被组件的字号影响布局</li></ul></li><li>Morphable blocks：尽可能透过不同的表象提炼相同结构的组件，以达到尽可能的复用和组件数最小化<ul><li>找出相同点和不同点</li><li>得出最佳的 HTML 结构</li><li>通过设置不同的样式展示出不同的效果</li><li>让 modifier (BEM 中的 M) 的数量尽可能的少</li></ul></li><li>额外的小贴士：命名规范和约定、避免在选择器上使用 ID 从而使得选择器的权重失控</li></ol><p>实际上每一条都不是很难，也不是没有见到过，但是总结的非常有系统性，给了大家一些很好开始的着手点。</p><p>另外 Zell 在聊天过程中也提到了很多我非常认同的观点和细节，想分享给大家：</p><ul><li>前端工程师是真正用户体验的“最后一道门”，身为前端工程师一定要有意识捍卫用户体验 (这句话后来跟 裕波 聊天的时候他说了一模一样的话，可见大家都十分认同)。</li><li>前端工程师一定要跟设计师“坐在一起”工作，一定要强沟通，才能把工作做好。</li><li>跟 Zell 聊到响应式在自己的工作中遇到很多困难的时候，Zell 出乎意料的大方对我说“你找我就对了”，即大方又自信。看得出来响应式在 Zell 看来已经是吃饭喝水一样了，我们自己包括周围的人却连一步都还没走出来，真是觉得惭愧。</li></ul><h3 id="从-API-的角度看组件的-CSS"><a href="#从-API-的角度看组件的-CSS" class="headerlink" title="从 API 的角度看组件的 CSS"></a>从 API 的角度看组件的 CSS</h3><p>我记录了一些要点和自己的理解：</p><ul><li>首先，通过 CSS 的发展史来看，我们一直试图通过一种特定的语法 (CSS) 来描述网页的样式，但在 web page -&gt; web app 的划时代趋势下，我们组织代码的方式也发生了变化，尤其是 CSS 的部分容易被人们忽视。</li><li>分享者 E0 把今天的 CSS 设计问题，从 API 的角度划分成了三个层次：<ol><li>对于组件的维护者来说：要把一部分 CSS 样式封装起来，供自己维护，同时也要避免被组件的使用者误修改或滥修改，通常这些样式会被内联或编译为无语义不可编辑的 CSS class</li><li>对于组件的使用者来说：要把一部分 CSS 用法暴露出来，供开发者灵活配置或修改，很多组件库会在文档中列出可以配置和修改的 CSS class，但除此之外，还有一些库做了很巧妙的不一样的封装，比如通过扩展的伪类或伪元素。这种方式我之前没有留意到过，有点开眼界</li><li>对于浏览器插件作者：这个角度也是我之前没有认真思考过的，就是说还有这样一群开发者，希望通过浏览器插件处理一些不同用户的特定需求。如果我们的组件希望对这些人友好，那么就多了一层考量。这时我们就想到了一些更加通用或规范化的，和具体工具、库、编译方式无关的设计，比如 CSS 自定义属性、无权重的选择器等</li></ol></li></ul><p>听过之后非常受启发。</p><p>这两份 slides 我也第一时间分享给了我们团队组件库的同学们了解学习了：）</p><h3 id="关于自己分享的-CSS-Houdini"><a href="#关于自己分享的-CSS-Houdini" class="headerlink" title="关于自己分享的 CSS Houdini"></a>关于自己分享的 CSS Houdini</h3><p>这些内容可能真的是有一点“超前”了，因为很多浏览器都还没实现，而且规范本身也没有稳定下来。但是我迫不及待的想分享出来，是因为我也听到了一些说法，说“CSS 很久没有什么新闻了”。那 CSS Houdini 绝对是一个可以让 CSS 更上一层楼的“重量级”的东西。希望可以通过分享 CSS Houdini 让大家对 CSS 更有信心和期待。</p><p>同时很多技术的“风向”都是由最底层的东西决定的，我们从规范层面对 CSS 有更多的了解，一定会对我们的实际工作有很多指导和借鉴的价值。如果你同时还是一个有开源精神的人，那么你可以从今天开始就构思一些基于 CSS Houdini 的工具和库了对吧，用这些工具和库加速 CSS Houdini 的落地，同时也尽快把一些之前没有 CSS Houdini 的时候大家用起来很别扭很勉强的东西汰换掉，更在这个过程中体会 web 带给我们的乐趣：）</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>另外几个分享也各有特色，总体上，我觉得这次 CSSConf CN 同时包含了 CSS 的规范、理念、工具、技巧、动画、八卦、吐槽各个方面，应该是尽可能照顾到了大家的兴趣和需求了。还是觉得这样的会议非常的棒。</p><p>我觉得 CSS 和动画、SVG、字体设计、3D 图形学、可访问性、语义化的 web 等话题有着非常紧密的联系，有很多有意义的延伸，并且这些话题也很难有独立的 Conf 了吧我估计。再加上 CSSConf 的主办者们，尤其是 裕波，是非常懂前端开发者们的，他们经营 CSSConf 的理念和方式我一直非常认同和欣赏，所以也许未来有一天，CSSConf 会比 JSConf 更受人关注。</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周末作为一名分享者参加了 &lt;a href=&quot;https://css.w3ctech.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSSConf CN&lt;/a&gt;，在厦门。&lt;/p&gt;
&lt;p&gt;其实除了自己的分享内容，这次我是带着很明确的目的参会的，因为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web 表单的未来</title>
    <link href="https://jinjiang.github.io//blog/the-future-of-web-forms/"/>
    <id>https://jinjiang.github.io//blog/the-future-of-web-forms/</id>
    <published>2017-08-04T03:00:16.000Z</published>
    <updated>2017-08-04T03:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自：<a href="https://blog.prototypr.io/the-future-of-web-forms-4578485e1461" target="_blank" rel="noopener">https://blog.prototypr.io/the-future-of-web-forms-4578485e1461</a> Matt West 的 The Future of Web Forms</p><p>license: <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC BY-SA 4.0</a></p><hr><p>如何通过会话式的界面让数据收集更加人性化。</p><p>Web 表单是从纸质媒介进化而来的。即设计一组标签和线框来限制输入，同时让数据处理变得跟容易。</p><p>毕竟，表单的目的是收集数据，以便执行操作。为了执行该操作，我们需要把收集的数据统一汇总。我们在界面上设计了一些约束以便达到统一汇总的目的。表单旨在符合流程上的需求，而非用户本身。</p><p>表单经常给人的感觉是冷冰冰的，没有人情味。因此，我们得到的回应往往也是冷酷和不人性的。我们不深入细节，如果一个朋友问你相同的问题，你可能会多一些回复，但这是一台电脑。他想要的只是数据，别的不在乎。就好像你在跟人说话但是人家并没有在听。为什么没人听的话说出来会让人觉得烦呢？</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/3710637212.jpg" alt=""><br>Image by <a href="https://www.flickr.com/photos/teegardin/5512347305/in/photolist-9p7dNM-nfdbBe-cDphCL-9xSJ1E-4ygMXx-6jXLSo-9oAgas-nytcFV-aXPWKv-2rxaS-6jXZNW-oTkWEk-iYYsDH-pMeotq-5SLAGV-6jERwK-6jBcih-iq2oUj-9c36uA-6wAbW4-7vWrZv-dRsLkh-99N1pk-g1vCAm-g4P8w-eSo6V4-biaFTP-6jk9td-J9DyZ-cQay4s-6jXYcS-9PSLHY-iYKUVr-h5Eh26-6jBXaA-7vTL6V-pMfC4t-5u8Nod-7b3sfu-fdPdkW-7vVobi-5Tscj8-7vUV6p-bDw2PE-6jxKBi-5Tww8J-89GCkF-6jxKTi-6jBWUG-eiwixk" target="_blank" rel="noopener">Ken Teegardin</a>.</p><p>和许多数字化的东西一样，表单已经被之前的形态严重影响。我们之所以往线框里填东西是因为我们以前在纸上就是这么画的。</p><a id="more"></a><p>我们在纸上主要的输入法是钢笔或铅笔。现在已经不一样了，我们被上百年的约束限制了自己。</p><p>技术已经从这些约束中解放了我们。我们已经拥有了创建更人性化的人机交互的工具。</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/4181232011.jpg" alt=""><br>Spike Jonze’s film “Her” provides an interesting prediction for how we might interact with computers in the future.</p><p>我们已经很接近在语音识别、自然语言处理和人工智能等方面与人类进行有意义的对话了。甚至我们的工具已经在构建足够优秀的体验了。</p><p>所以我们回到表单。我们该如何使用这些工具使得表单更人性化呢？</p><p>我们需要摆脱之前对于表单界面的预设。聚焦在通过技术构建一个更佳自然的体验，而不是去除操作层面的约束。</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/2141635702.png" alt=""><br>A conversation with Facebooks chat bot “Poncho”.</p><p>在过去几年中，我们已经看到了一些新产品致力于通过科技让我们的交互更自然。Siri、Alexa、chat bots 都让我们朝着正确的方向发展，但是我们还没有看到这些创新以某种方式融入到浏览器界面中。</p><p>我们有非常多的潜力在更加会话式的 web 界面上，当我们需要收集数据时，我们仍然从一堆输入框和下拉框中构建表单。</p><p>有些人在推动这件事。保险服务 <a href="https://withjack.co.uk/quote/" target="_blank" rel="noopener">Jack</a> 最近发布了一个令人印象深刻的页面来收集保险报价所需的细节。</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/1469363781.png" alt=""><br>The “Get a Quote” page from <a href="https://withjack.co.uk/" target="_blank" rel="noopener">withjack.co.uk</a></p><p>虽然回复依然是被约束的，但是这个收集数据的设计流程已经创造出了更加愉悦和友善的体验。</p><p>向用户展示一个标准的 web 表单因此而变得更加容易，但是这样的用户交互更像是一个会话的过程，Jack 已经创造出了更加自然的感受。</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/993446137.png" alt=""><br>Adrian Zumbrunnen’s conversations website <a href="http://azumbrunnen.me/" target="_blank" rel="noopener">azumbrunnen.me</a></p><p>Adrian Zumbrunnen 在发布他的会话式的个人网站之后引起了互联网的关注。Adrian 设计了一个界面，通过一些回复选项来引导用户浏览他的 UI/UX 作品。Adrian 的网站巧妙的考虑到了用户如何到达他的网站并以此为信号来理解用户所处的情景。</p><p>我们的方向是对的，但感觉还是少了什么。从技术角度看，构建一个真实的会话式界面需要理解用户的意图和语境，而不仅仅是一些回复选项和位置摆放很聪明的文本框。我们需要基于已经做好的 chat bot 且开发出能够让人们用自然语言与其交流的界面。</p><p>界面甚至在开始之前就应该知道我们是谁。底层技术已经有现成的了，那就是浏览器的自动填表。你所有的细节都存在同一个地方，对于一个网站来说，一个简单的请求就可以访问。</p><p>该界面应该能够适配当前所处的情境。会话是你是从网站的帮助支持页面开始的还是从营销站点的首页开始的？这些信号可以帮助我们理解用户的语境并为其定制适当的系统回复。这些事情 Adrian 的网站并没有做。</p><p>让我们体验一下如何把用户注册流程变得更加会话式。</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/68310827.png" alt=""><br>What would the sign up flow look like if we moved beyond forms?</p><p>我们今天拥有做这件事相应的数据，但是把所有的东西一起提供出来以创造这样一个自然的体验是真正难的地方。</p><p>再考虑牵连到可访问性、隐私、多语言支持、赋予情绪和同理心的设计。如果我们打算通过技术引入一个全新的更有意义的交互设计，这些都是我们今天要去面临和克服的挑战。</p><p>没想到我们已经走到这么远了，但是这里仍然有很多事情要做。未来就在不远处的转角，但我们要敢于去做才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自：&lt;a href=&quot;https://blog.prototypr.io/the-future-of-web-forms-4578485e1461&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.prototypr.io/the-future-of-web-forms-4578485e1461&lt;/a&gt; Matt West 的 The Future of Web Forms&lt;/p&gt;
&lt;p&gt;license: &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CC BY-SA 4.0&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如何通过会话式的界面让数据收集更加人性化。&lt;/p&gt;
&lt;p&gt;Web 表单是从纸质媒介进化而来的。即设计一组标签和线框来限制输入，同时让数据处理变得跟容易。&lt;/p&gt;
&lt;p&gt;毕竟，表单的目的是收集数据，以便执行操作。为了执行该操作，我们需要把收集的数据统一汇总。我们在界面上设计了一些约束以便达到统一汇总的目的。表单旨在符合流程上的需求，而非用户本身。&lt;/p&gt;
&lt;p&gt;表单经常给人的感觉是冷冰冰的，没有人情味。因此，我们得到的回应往往也是冷酷和不人性的。我们不深入细节，如果一个朋友问你相同的问题，你可能会多一些回复，但这是一台电脑。他想要的只是数据，别的不在乎。就好像你在跟人说话但是人家并没有在听。为什么没人听的话说出来会让人觉得烦呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/3710637212.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Image by &lt;a href=&quot;https://www.flickr.com/photos/teegardin/5512347305/in/photolist-9p7dNM-nfdbBe-cDphCL-9xSJ1E-4ygMXx-6jXLSo-9oAgas-nytcFV-aXPWKv-2rxaS-6jXZNW-oTkWEk-iYYsDH-pMeotq-5SLAGV-6jERwK-6jBcih-iq2oUj-9c36uA-6wAbW4-7vWrZv-dRsLkh-99N1pk-g1vCAm-g4P8w-eSo6V4-biaFTP-6jk9td-J9DyZ-cQay4s-6jXYcS-9PSLHY-iYKUVr-h5Eh26-6jBXaA-7vTL6V-pMfC4t-5u8Nod-7b3sfu-fdPdkW-7vVobi-5Tscj8-7vUV6p-bDw2PE-6jxKBi-5Tww8J-89GCkF-6jxKTi-6jBWUG-eiwixk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ken Teegardin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;和许多数字化的东西一样，表单已经被之前的形态严重影响。我们之所以往线框里填东西是因为我们以前在纸上就是这么画的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>苹果正在做一些他们的程序员明摆着不想要的东西</title>
    <link href="https://jinjiang.github.io//blog/apple-is-about-to-do-something-their-programmers-definitely-dont-want/"/>
    <id>https://jinjiang.github.io//blog/apple-is-about-to-do-something-their-programmers-definitely-dont-want/</id>
    <published>2017-07-31T18:49:46.000Z</published>
    <updated>2017-07-31T18:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自: <a href="https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487" target="_blank" rel="noopener">https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487</a></p><p>Jul 29, 2017</p><p>作者 <a href="http://anildash.com/" target="_blank" rel="noopener">Anil Dash</a> 是 Fog Creek Software 的 CEO，致力于让科技变得更人性和道德一些，同时他也是 Medium 的顾问。</p><hr><blockquote><p>苹果在 Apple Park 这个漂亮的新办公楼上花了 50 亿美金，却犯了一个完全可以避免的极其昂贵的错误：让他们的程序员工作在一个开放式的格局中。这真让人惊讶。</p></blockquote><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/2254787802.jpg" alt=""></p><p>我在 Fog Creek Software 工作，我们的联合创始人兼前 CEO <a href="https://medium.com/u/869c7e626b83" target="_blank" rel="noopener">Joel Spolsky</a> 在<a href="https://www.joelonsoftware.com/2000/04/19/where-do-these-people-get-their-unoriginal-ideas/" target="_blank" rel="noopener">至少 17 年前</a>就已经针对开放式办公室对于程序员产能的糟糕影响撰文了。他在这方面的洞察基于了 Tom DeMarco 和 Tim Lister 的经典书籍<a href="https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams" target="_blank" rel="noopener">《Peopleware》</a>——该书已经出版了三十年。所以这其实不是什么全新的观点。当然在这数十年里，也已经有无数的<a href="http://theconversation.com/open-plan-offices-attract-highest-levels-of-worker-dissatisfaction-study-18246" target="_blank" rel="noopener">学术研究确认</a>了同一个结论：人们在开放式空间办公是烦躁的、注意力不集中的、常常不开心的。</p><p>这不是说开放式办公环境一无是处——它能够营造很好的协作和联络的氛围。对于市场或销售团队来说，共享空间是非常有意义的。但是对于需要身处某种工作流状态的任务来说呢？这个问题从科学的角度是有定论的。</p><p>那就是把门关上。</p><a id="more"></a><h3 id="保持在工作流中"><a href="#保持在工作流中" class="headerlink" title="保持在工作流中"></a>保持在工作流中</h3><p>现在，如果我们的工作或角色需要特定工作流的时候，那事情就能通过排除一切干扰而获益，编程或许就是这种绝无仅有的最好的例子。而苹果拥有一批这个世界上最顶尖的程序员，所以很显然应该给予他们非常好的环境。</p><p>这就是为什么<a href="https://www.wsj.com/articles/how-jony-ive-masterminded-apples-new-headquarters-1501063201" target="_blank" rel="noopener">华尔街日报的这篇醒目的文章</a>里会出现这段关于苹果新总部的尤其刺眼的边注：</p><blockquote><p><strong>数以千计的</strong> Apple Park 的雇员都会出现在 Ive 的办公视线内。很多人都将坐在开放空间，而不是以往的小办公室。<mark>程序员们都会担心他们的工作氛围太过嘈杂和注意力不集中。</mark>……</p></blockquote><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/941992970.png" alt=""></p><p>通常，公司会以预算为由把程序员安排在开放式办公室。确实让每个程序员都有一个自己的封闭办公室是一笔不小的开销。但是鉴于苹果已经在这个新园区投资了 50 亿美金，且用上了<a href="https://qz.com/905934/even-the-toilets-in-apples-aapl-campus-2-are-inspired-by-the-iphone/" target="_blank" rel="noopener">被 iPhone 设计影响了的定制抽水马桶</a>，你很难确信这是因为省钱而做的决定。</p><p>取消私人办公室的另一个可能的原因是，也许公司并不知道它的员工们的喜好。但是这个问题是可测试的——我们不带任何倾向性的暗示，来询问一下大家希望办公室是什么样子的，看看大家的回应如何。</p><blockquote><p>你曾经或现在拥有的办公室里的最好的特点是什么？</p><p>Anil Dash (@anildash)<br>2:47 AM - Jul 19, 2017</p></blockquote><p><a href="https://medium.com/media/1e30d93e0c22e81d448111d4f478fa20?postId=fc19f5f4487" target="_blank" rel="noopener">Twitter Link</a></p><p>在数百则回复中，你会发现许多人在谈论他们多么高兴自己有一个，或希望自己有一个可以把门关上的私人办公室。</p><p>毫无疑问如果苹果和他们自己的团队交流过后，能够得到相同的回复。所以唯一剩下的可能就是在这个行业里，没有足够的人真正相信程序员值得拥有一个私人办公室。所以我们会继续大声呼吁这件事情。</p><h3 id="近距离看看"><a href="#近距离看看" class="headerlink" title="近距离看看"></a>近距离看看</h3><p>来参观一下 Fog Creek 在纽约的总部</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/1791376931.jpg" alt=""></p><p><a href="https://www.google.com/maps/@40.706976,-74.0132501,0a,29.2y,273.42h,100.56t/data=!3m4!1e1!3m2!1su6fRkLZ36IAAAAQIt5lP8A!2e0?source=apiv3" target="_blank" rel="noopener">Google Map Link</a></p><p>将近二十年前，我记得自己在 Joel 的博客上看到了有关 Fog Creek 新办公室的构造，后来当它完工的时候，我记得看到纽约时报<a href="http://www.nytimes.com/2009/02/08/realestate/commercial/08sqft.html" target="_blank" rel="noopener">热切的报道</a>它的创新。在那时，我从未想象过我有一天会在那里工作。我看着那篇文章，脑海里幻想着自己在那里的样子，带有一点怀疑的问这些努力是否值得。</p><p>现在我得承认，当开始想象自己在 Fog Creek 拥有一间新办公室的时候，我一度被诱惑到了，我想知道通过像其它几乎每一家公司一样使用开放式办公室来省一些钱是否真的很好。这样做是很容易的。</p><p>现在 Fog Creek 已经改变了很多——我们公司大约三分之二的工作是远程进行的，尽管几乎所有人都在家中的办公室办公，你猜到了，都是关门的。同时像销售和客服这样的团队从开放式的办公区域中获益。我们可以讨论到所有人的意见一致为止。</p><p>不过即便是共享空间的团队也会因为我们在新办公室里提供了电话亭而兴奋，这会方便他们在一个私人空间里打电话。同时我们的技术人员仍然和以前一样拥有超高的工作效率，没有低效的时段，这可以归功于他们有适合他们工作的正确的环境。</p><p>最重要的是，专注于创造一个非常棒的工作环境，甚至让我们考虑新的想法，来帮助人们同时拥有两个最好的世界，犹如一辆“安静的汽车”置身于一个大型的会议室。这样的地方能让人们坐在一起但同时仍然可以享受安静和平静，灵感来源于大家最喜欢的 <a href="https://www.amtrak.com/onboard-the-train-quiet-car" target="_blank" rel="noopener">Amtrak amenity</a>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>如果一家公司想把产品做得像苹果一样成功，我们永远无法给出建议。尽管我们为 <a href="https://glitch.com/" target="_blank" rel="noopener">Glitch</a> 和 <a href="https://fogbugz.com/" target="_blank" rel="noopener">FogBugz</a> 而无比的自豪，我们仍然对苹果近几十年来所做的一切深表敬意。但是我们不希望对这个有机会避免的错误袖手旁观而让其继续下去，因为这是一个苹果 (同时也是每一家自己有程序员的公司！) 不费吹灰之力就可以解决的缺点。</p><p>我们很高兴这么多公司知道在他们的雇员身上投资——从医疗保健到最新最棒的计算机硬件的一切东西。但是当他们需要集中精神的时候，也强求每个工作人员都要共享一个开放式的空间时，哪怕是最大最成功的公司也是时候 think different 了吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自: &lt;a href=&quot;https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jul 29, 2017&lt;/p&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://anildash.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Anil Dash&lt;/a&gt; 是 Fog Creek Software 的 CEO，致力于让科技变得更人性和道德一些，同时他也是 Medium 的顾问。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;苹果在 Apple Park 这个漂亮的新办公楼上花了 50 亿美金，却犯了一个完全可以避免的极其昂贵的错误：让他们的程序员工作在一个开放式的格局中。这真让人惊讶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/2254787802.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我在 Fog Creek Software 工作，我们的联合创始人兼前 CEO &lt;a href=&quot;https://medium.com/u/869c7e626b83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joel Spolsky&lt;/a&gt; 在&lt;a href=&quot;https://www.joelonsoftware.com/2000/04/19/where-do-these-people-get-their-unoriginal-ideas/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;至少 17 年前&lt;/a&gt;就已经针对开放式办公室对于程序员产能的糟糕影响撰文了。他在这方面的洞察基于了 Tom DeMarco 和 Tim Lister 的经典书籍&lt;a href=&quot;https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Peopleware》&lt;/a&gt;——该书已经出版了三十年。所以这其实不是什么全新的观点。当然在这数十年里，也已经有无数的&lt;a href=&quot;http://theconversation.com/open-plan-offices-attract-highest-levels-of-worker-dissatisfaction-study-18246&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;学术研究确认&lt;/a&gt;了同一个结论：人们在开放式空间办公是烦躁的、注意力不集中的、常常不开心的。&lt;/p&gt;
&lt;p&gt;这不是说开放式办公环境一无是处——它能够营造很好的协作和联络的氛围。对于市场或销售团队来说，共享空间是非常有意义的。但是对于需要身处某种工作流状态的任务来说呢？这个问题从科学的角度是有定论的。&lt;/p&gt;
&lt;p&gt;那就是把门关上。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么我不会无偿加班且你也不应该</title>
    <link href="https://jinjiang.github.io//blog/why-i-dont-unpaid-overtime-and-neither-should-you/"/>
    <id>https://jinjiang.github.io//blog/why-i-dont-unpaid-overtime-and-neither-should-you/</id>
    <published>2017-04-01T00:06:05.000Z</published>
    <updated>2017-07-31T18:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自：<a href="http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you" target="_blank" rel="noopener">http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you</a></p><p>原文写于 2012 年，至今已经有一段时间了，前段时间这篇文章又被大家翻出来热烈讨论，看过之后有些感触，所以翻译了一下</p><hr><p>我是一个在美国待了 30 年的程序员，我有过一周工作超过 40 小时的经历，这在行业里面并不常见，但是我<a href="http://dict.cn/rarely" target="_blank" rel="noopener">很难</a>因此而得到更多的薪水。</p><p>总之，我现在发现整个做法<a href="http://dict.cn/nauseating" target="_blank" rel="noopener">很恶心</a>。</p><p>我并不是针对自营或创业等多干活儿就能得到更多回报的情况。我曾经在 80 年代中期到 90 年代开过两个小的软件公司，并且工作时间也很长，但是我们会共享全部的成果，而第二家公司我们在合同里就定好了多劳多得的规矩。当然这不是我们今天讨论的重点。</p><p>如果我为一家大公司工作并且谈好了薪水，那我的预期就是我在标准的时间内，即公认的 (至少在美国) 一天 8 小时一周 5 天，尽我所能完成工作。如果他们希望我每周工作 70 个小时或有些主管期望团队每天都来上班，现在的我是会拒绝的。为什么呢？</p><p>当我们决定工作赚钱的时候，我们假定工作的主要原因是为了换取我们生活所需的开销。雇员的预期是他们会获得等价于这笔薪水的产出。但问题在于，雇主概念中的价值经常和雇员的不一样，尤其在美国和亚洲。许多公司期望薪水是固定的，但是他们创造这些价值需要完成的工作是不确定的。雇主觉得只要提高对雇员的预期和要求，就能够获得更大的回报，这样他们就可以通过为每份薪水延长工作时间来降低实质的劳动成本。</p><p>这对于雇员来说意味着什么？如果你同意了，那么你实际上就认同了自己的工作更廉价。甚至这种工作其实就是无偿的。那么作为雇员你在这样的无偿工作中收获了什么呢？在绝大多数雇主面前，你什么也没有得到。如果你是一个主管，也许会得到晋升，但是作为程序员你职业发展的道路不只是做管理这一条。如果你连续几个月每周编码超过 80 个小时，通常情况下得到的回报和一周努力工作 40 小时差不多。</p><a id="more"></a><p>在一些行业里，比如 AAA 游戏工作室，准备发布大型游戏这样的关键时刻的经历都是非常痛苦的。而你看了很多人们玩命工作然后发布没多久就下岗了的故事。当然你是可以选择休息的，但是付出的代价是多少？收益又是多少？</p><p>现在想象一下你自己是一个供应商 (我现在就是)。如果你要求在协议之上做更多的工作，那么公司付钱，供应商付出劳动。也许不会有更高的回报但不会比正常情况少。现在你是在为工作获取应有的回报。但奇怪之处在于，显然公司更倾向于根据时间付钱给你而不是你的实际产出，所以他们有的时候不会允许供应商加班。那他们为什么简单的要求雇员无偿工作或自告奋勇呢？</p><p>美国工人一般都有 10 天左右的年休假，有的时候还额外有几天病假；但是全职的美国工人评价一年只休息 5～7 天。在世界上很多地方，尤其是欧洲，政府<a href="http://dict.cn/mandates" target="_blank" rel="noopener">授权</a> 20～30 天年假，人们基本上都会把这些假期用掉。在很多国家加班并不普遍，无偿加班是极少的，甚至是非法的。人们配得上工作之外的生活，对于他们来说，只为雇主埋头工作是<a href="http://dict.cn/unimaginably" target="_blank" rel="noopener">极其</a>愚蠢的。而我们在美国 (以及亚洲很多地方) 很少这么思考问题。</p><p>我曾经有一个朋友，他的老板希望她的黑莓手机保持 24x7 待命状态。一年以后她拒绝并辞职了。她的老板为此<a href="http://dict.cn/livid" target="_blank" rel="noopener">大为恼火</a>。而在那段时间她没有获得任何多余的回报。那我们为什么还这么做呢？</p><p>在欧美之间有一个很大的不同，美国的健康保险通常是和你的雇主绑定的，几乎没有其他地方给你<a href="http://dict.cn/virtually" target="_blank" rel="noopener">实质的</a>保障。如果你失业了，那么你得在有限的时间里支付一大笔 (COBRA) 费用，即便你找到了一份新工作，你的健康保险在 6 个月内也没法生效。所以对失业的恐惧感以及健康保险会让你更倾向于接受更长的无偿工作时间。感觉这个系统设计之初就想阻止你跳来跳去 (尤其是你成家之后)。在欧洲你的健康保险不会和雇主做任何绑定。如果公司想留住一个有价值的员工，他们就得采取一些积极的措施把你<a href="http://dict.cn/entice" target="_blank" rel="noopener">留</a>住。很多欧洲国家 (和欧元区) 你很难期待或要求别人无偿加班。</p><p>另外一个无偿加班的副作用是更少的人被雇佣。如果你长期让你的雇员每周工作 60～80 小时，你就不需要雇佣更多的人。但是对于雇员来说他们收获了什么呢？基本是没有什么收获的。</p><p>我想说的重点是，如果你付钱给我，那么我为你好好工作 40 小时，如果其他人愿意工作 60 或 80 小时，他们就更有价值而我就贬值了？我就应该由于没有把人生的全部都放在工作上而被解雇？那些愿意工作两倍时间的人就真的交付了两倍于我交付的价值吗？你可以反驳如果公司是根据工作时间给员工回报的，那么工作 80 小时的人就得到两倍回报，但这只是从雇主的角度来看。而雇员创造了更多的价值 (为公司带来了更多的收入) 但是没有得到任何更多的回报。当然你可以<a href="http://dict.cn/get%20rid%20of" target="_blank" rel="noopener">无视</a>我，找到更多这样的公司，但是我对这种现代的“奴隶制”并<a href="http://dict.cn/unappealing" target="_blank" rel="noopener">不感冒</a>。</p><p>工作不能也不应该是一个人的生活的全部，这绝对是欧洲式的思维。生活对我来说也意味着更多。然而在美国有一种非常商业化的观点，就是如果你根据工作时间付钱，那么公司就不会成功；如果人们每年要休假 20 天，那么他们就会失败；一个雇员工作之外的生活一文不值。</p><p>我从 Steve Jobs 听到的一个有意思的故事是，在 iPhone 装备的几周前 Steve 要求他们把塑料屏幕换成玻璃的，所以他们通知中国的工厂，那边立刻把上千名工人叫起来，每人发一块饼干一杯茶水，让他们每天连续工作 12 小时，直到 iPhone 装配好。真是一个神奇的故事，但同时也是一个悲伤的故事。他们如此轻易的放弃了生活 (我相信他们还是根据工作时间得到了报酬) 甚至乐在其中，就为了有份工作。而且我从雇主这里听到用这个故事来激励大家做相同的事情——“如果你每周不工作 80 个小时，那么在中国某些人就会顶替你的工作”。而企业会通过这些<a href="http://dict.cn/evoke" target="_blank" rel="noopener">引起</a>笑声的国家取得成功。</p><p>经济是一门复杂的“科学”，我不想为此争辩太多。但是从一个个人工作者的角度看，就是一份付出一分回报。我有技能，公司有需求，我能作为一个有价值的工作者，但是这里是有度的。我不能对你或你的处境说什么，但是对我来说我的工作能力或工作期待是一个有限的范围。可能这是我的德国人的遗传，可能是因为我曾经在我的小公司每周工作 80 个小时的结果，可能我变老了也变聪明了，但是我更愿意享受工作和生活之间的平衡。</p><p>当我在 General Dynamics 的第一份工作时，我认识一位年轻的经理，他每周七天连续工作并且每天工作很长时间。有天在一个会上他突然猝死了。你说他没日没夜的工作最后得到了什么呢？</p><p>不为别人，也不为我自己。我努力工作，但到点该回家就会回家。你也应该这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自：&lt;a href=&quot;http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文写于 2012 年，至今已经有一段时间了，前段时间这篇文章又被大家翻出来热烈讨论，看过之后有些感触，所以翻译了一下&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我是一个在美国待了 30 年的程序员，我有过一周工作超过 40 小时的经历，这在行业里面并不常见，但是我&lt;a href=&quot;http://dict.cn/rarely&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;很难&lt;/a&gt;因此而得到更多的薪水。&lt;/p&gt;
&lt;p&gt;总之，我现在发现整个做法&lt;a href=&quot;http://dict.cn/nauseating&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;很恶心&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我并不是针对自营或创业等多干活儿就能得到更多回报的情况。我曾经在 80 年代中期到 90 年代开过两个小的软件公司，并且工作时间也很长，但是我们会共享全部的成果，而第二家公司我们在合同里就定好了多劳多得的规矩。当然这不是我们今天讨论的重点。&lt;/p&gt;
&lt;p&gt;如果我为一家大公司工作并且谈好了薪水，那我的预期就是我在标准的时间内，即公认的 (至少在美国) 一天 8 小时一周 5 天，尽我所能完成工作。如果他们希望我每周工作 70 个小时或有些主管期望团队每天都来上班，现在的我是会拒绝的。为什么呢？&lt;/p&gt;
&lt;p&gt;当我们决定工作赚钱的时候，我们假定工作的主要原因是为了换取我们生活所需的开销。雇员的预期是他们会获得等价于这笔薪水的产出。但问题在于，雇主概念中的价值经常和雇员的不一样，尤其在美国和亚洲。许多公司期望薪水是固定的，但是他们创造这些价值需要完成的工作是不确定的。雇主觉得只要提高对雇员的预期和要求，就能够获得更大的回报，这样他们就可以通过为每份薪水延长工作时间来降低实质的劳动成本。&lt;/p&gt;
&lt;p&gt;这对于雇员来说意味着什么？如果你同意了，那么你实际上就认同了自己的工作更廉价。甚至这种工作其实就是无偿的。那么作为雇员你在这样的无偿工作中收获了什么呢？在绝大多数雇主面前，你什么也没有得到。如果你是一个主管，也许会得到晋升，但是作为程序员你职业发展的道路不只是做管理这一条。如果你连续几个月每周编码超过 80 个小时，通常情况下得到的回报和一周努力工作 40 小时差不多。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>寄语应届生：走出校园的几个人生转变</title>
    <link href="https://jinjiang.github.io//blog/for-after-college/"/>
    <id>https://jinjiang.github.io//blog/for-after-college/</id>
    <published>2017-03-29T19:24:24.000Z</published>
    <updated>2017-03-29T19:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近收到个邀请，<a href="http://weibo.com/2724465062/ECaVuAyZk" target="_blank" rel="noopener">有机会和大学生的在线互动交流</a>，体裁不限。我选了上面这个题目，整理了一些心得感想，虽然活动很快就结束了，但是这些想法我打算还是以文字形式备忘一下。如果能给更多人帮助或参考，我会倍感欣慰。</p><h3 id="目标的转变"><a href="#目标的转变" class="headerlink" title="目标的转变"></a>目标的转变</h3><p>作为学生，毫无疑问是以学业为重。在校园里，大家不出意外都会把学习定为最大的目标，围着功课转。但是工作之后，你可能面对很多事情要处理，怎么有所成就？怎么赚钱？怎么照顾好自己？怎么照顾好家庭……除了目标本身不同之外，我觉得更大的不一样在于，在相当长且连续的学生生涯中，我们没有太多选择的余地和必要，即便是有什么目标，也基本上是被动接受或被灌输的。但是走出校园之后，你面对的是一个无比自由开放的社会。这个时候你需要的不是意见，而是主见。甚至你是否做好了准备，有了足够的本事从事一项工作，还是继续学习深造修炼自我，直到自己准备好为止再工作？这也需要你的主见 (并为这个主见承担相应的后果，某种角度上)。最终很多选择是开放的，权衡的，遵从自己内心的结果。</p><p>还有一点我想说的是，因为你拥有了新的目标，而且不再会有人逼着你学习，从外部给你学习上的压力，所以客观上学习的环境也没有那么好那么纯粹了，学习这件事情会逐渐变得让你渴望、珍惜、喜欢。希望你还没有因为繁重的学业对新事物新知识，尤其是表面上枯燥但实际上对你有很多帮助的东西，失去动力。我们在校园里更多的是学习知识，然后推导这些知识可以用在什么地方；走出校园之后更多的需要思考，我遇到一个问题想解决它，究竟有多少知识哪些知识可以为我所用？也许在未来的某一天你会突然觉得，当时在校园里，学习环境那么好，怎么没有多看两本书，多做些训练。所以最好不要丢下自己看书学习的习惯，给自己定个长期的学习计划，有空就多看两本书。</p><h3 id="学会社交"><a href="#学会社交" class="headerlink" title="学会社交"></a>学会社交</h3><p>坦白地讲我觉得这在校园里并不是必备的技能。但是走出校园之后，它非常非常重要。这也是为什么几乎所有的公司都会给员工做沟通培训 (尽管那并不一定管用)。社交并不只是沟通而已，也不只是表达，更是聆听，是待人接物的每一个细节。我发现很多人在工作中，最简单的两件事情做不好，也不知道该怎么做，那就是：1 如何写邮件、2 如何开会。这表面上是职场礼数的范畴，也有很多文章介绍这些职场礼数，看上去就是个知识点罢了。但实际上一个人在理解和实践它的背后，反映的是修养，甚至是教养。这不是一两篇文章能够教会你的，是你平时为人处事方式的积累和感悟。</p><p>另外社交能力的重要性不止体现在工作中，体现在你步入社会之后可能会面对的各种场合的各种人，比如和同事下班之后一起组织些活动放松消遣一下，和老乡或老同学叙叙旧——这些也都是我刚毕业的时候经常会做的事情。但是这里我认为更重要的场景是：学会如何跟陌生人打交道，如何更主动的和陌生人交流，和这个社会交流。从最简单的跟陌生人问路、跟陌生的房东租房子、甚至搭讪对吧 ^_^，到跟不同性格的服务员、乘务员、售票员、公交车司机、出租车司机沟通或寻求帮助，再到你如何主动但又不会让对方和周围人尴尬的帮助别人，包括你是否会本能的路见不平挺身而出……抱歉这可能有点超出社交这个话题了。但这些都是有关联的不是吗？每个人在这个社会中都是一个独立的个体，但又是相互依赖相互依靠的一个集体社会。想真正融入这个社会，我觉得这些都是必须的。</p><p>最后，关于社交，还有一点很重要，就是在你刚刚加入一个公司或团队的时候，你周围的人一开始对你来说都是陌生人。这个社会上可能有很多适合你的机会，但它们不会主动找到你头上，这个时候需要你学会跟陌生人打交道。好的社交能力会让你的人生更有安全感，对自己办好一件事更有信心。和别人交流同样是一个完善自我认知的过程，尝试接受更多不同的观点，发现并理解不同的看问题的角度，有助于更认清自己，避免自以为是 (相信我，这种事情别人帮不上忙的，只能你自己领悟)。</p><h3 id="个人发展"><a href="#个人发展" class="headerlink" title="个人发展"></a>个人发展</h3><p>我觉得找工作这件事情，更多的要从兴趣出发，而不是所谓的“前途”。我逐渐越来越认同和相信一句老话：“三百六十行，行行出状元”。首先，如果对这件事情没有兴趣，你很难“用心”做好它，这样的状态也不是长久的；第二，我们已经看得见摸得着的“前途”和“机会”，往往已经不是什么好机会了，尤其是如今互联网时代事情变化发展这么快。而且那些真正抓住机会的人往往都是在完全没人看好的时候就开始全身心的投入在这个行业或方向上，才能在“机会”来临的时候抓住它，我不觉得这些人只是更厉害的“投机主义者”，如果没有兴趣在背后趋势着这些人，他们又是怎样才能在枯燥 (往往还伴随着高风险和不确定性) 的领域里这么坚定的做到今天呢？所以我的个人建议是，找工作，就完全追随自己的兴趣和内心就好了，不要想太多“这个行业比较赚钱比较有前途”之类的——它最多是你的一个参考项。找到自己的兴趣所在，相信它，相信自己，保持专注，一定有最好的回报，剩下的东西交给运(时)气(间)就好了。</p><p>再有就是要相信专业的力量，对学问保有“敬畏之心”。这里的学问不只是纯职业技术，也包括做事方式方法等等一切社科类的研究。<!--虽然我们看到今天很多行业存在这样一种不健康的现象：做 X 不赚钱，然后免费做 X 出了名，靠走穴之类的“不专注”来赚钱；再接下来大家发现 X 方面不专业也没关系，只要“出了名”，后面的“商演走穴赚钱”也行得通，而“出名”的方法又有很多，所以渐渐的没有人相信专业 X 的价值。我不知道这个 X 换成音乐、演技、技术之类的名次是不是都适用，但是这种成功只是少数个体的成功，而且是很短暂的，更重要的是这并不是一个行业和社会的成功。-->如果一个行业的专业性丢掉了，整个行业也就被毁掉了，最后大家会一起丢掉工作，一起失败。</p><p>这种东西我觉得跟很多已经被一份工作或长期不良型的环境所固化思想的“老家伙”们讲已经不一定有意义和效果了。但是对于打算或刚刚从校园步入社会，有理想，有抱负，承载着社会的未来的大学生们来说，我希望有机会在这方面多呼吁一下。尊重和相信专业的力量，耐得住性子，不要被一时的挫折、不走运或委屈左右，多多磨练自己，你一定不会后悔。</p><h3 id="So-Are-You-Ready？"><a href="#So-Are-You-Ready？" class="headerlink" title="So Are You Ready？"></a>So Are You Ready？</h3><p>：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近收到个邀请，&lt;a href=&quot;http://weibo.com/2724465062/ECaVuAyZk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有机会和大学生的在线互动交流&lt;/a&gt;，体裁不限。我选了上面这个题目，整理了一些心得感想，虽然活动很快
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如果管理是唯一可走的路，那就完蛋了</title>
    <link href="https://jinjiang.github.io//blog/if-management-is-the-only-way-up-we-are-all-fd/"/>
    <id>https://jinjiang.github.io//blog/if-management-is-the-only-way-up-we-are-all-fd/</id>
    <published>2017-03-28T04:34:18.000Z</published>
    <updated>2017-07-31T18:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自：<a href="https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/" target="_blank" rel="noopener">https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/</a></p><p>注：作者 Rand 是 Moz 的 CEO，文中反复出现两个词：IC (Individual Contributor) 和 PW (People Wrangler)，分别翻译成了一线员工和经理人。</p><hr><p><a href="http://everywhereist.com/" target="_blank" rel="noopener">Geraldine</a> 很喜欢她曾经在 Cranium 的工作 (西雅图的<a href="http://dict.cn/board%20game" target="_blank" rel="noopener">桌游</a>初创公司，在 Hasbro 收购他们并<a href="http://dict.cn/layoffs" target="_blank" rel="noopener">裁员</a><a href="http://dict.cn/prior" target="_blank" rel="noopener">之前</a>)。她为桌游撰写问题，并为包装盒和营销材料撰写<a href="http://dict.cn/copy" target="_blank" rel="noopener">文案</a>。她很擅长这个。但是发生了一些奇怪的事情——他们想让她晋升。我记得她晚上回家后<a href="http://dict.cn/endlessly" target="_blank" rel="noopener">非常的</a><a href="http://dict.cn/fretting" target="_blank" rel="noopener">苦恼</a>。她不想让人们向她汇报。她不想在团队中拥有更大的责任。她只想写写东西。</p><p>这很奇怪。当我们审视一家公司的结构时，很容易发现团队需要很多高质量的一线员工 (IC) 以及少数高质量的<a href="http://dict.cn/wrangler" target="_blank" rel="noopener">经理人</a>。然而我们的<a href="http://dict.cn/corporate" target="_blank" rel="noopener">公司</a>文化和这个世界的“模式”已经让我觉得除非你要带人，否则你的影响力、薪水、利益、职位和自我价值都不会增长。</p><p><a href="http://www.urbandictionary.com/define.php?term=I%20call%20bullshit" target="_blank" rel="noopener">这都什么乱七八糟的。</a></p><p>我过去写过关于多样化成长轨迹的重要性——<a href="https://moz.com/rand/whats-the-right-team-structure/" target="_blank" rel="noopener">一线员工和经理人</a>——但是我们最近在 Moz 花了大量的时间碰撞想法，很快会实施一个新的职位/团队的结构，最终付诸实践，我对此充满期待。</p><p>现在我会为一个在其工作岗位上做的很优秀的一线员工表达对管理的兴趣而担心。我担心这种渴望的很<a href="http://dict.cn/significant" target="_blank" rel="noopener">重要的</a><a href="http://dict.cn/portion" target="_blank" rel="noopener">一部分</a>不源自真正的管理责任感，而是因为他们想要在职业生涯和/或影响力上得到提高，并且认为这是唯一的办法。</p><p>我画了这张图来辅助<a href="http://dict.cn/illustrate" target="_blank" rel="noopener">说明</a>两种角色之间的不同：</p><p><img src="https://moz.com/rand/wp-content/uploads/2013/04/ics-vs-pws-small.gif" alt="ics-vs-pws-small"><br>(<a href="https://moz.com/rand/wp-content/uploads/2013/04/ics-vs-pws-large.gif" target="_blank" rel="noopener">大图</a>)</p><a id="more"></a><p>一线员工为他们自己及其工作负责。因为他们以一线员工的方式取得了长足的发展，所以他们的影响力变得更加广泛。一个在 Moz 的好的例子就是 <a href="http://www.seomoz.org/users/profile/22897" target="_blank" rel="noopener">Dr. Pete</a>，他<a href="http://dict.cn/recognize" target="_blank" rel="noopener">判断</a>公司的战略<a href="http://dict.cn/imperative" target="_blank" rel="noopener">指示</a>并随之<a href="http://dict.cn/pitch%20in" target="_blank" rel="noopener">协力投入</a>。他通过审查来协助大数据操作，通过<a href="http://dict.cn/tactical" target="_blank" rel="noopener">战术</a>指导和策略输入来辅助市场，发表如此高质量的<a href="http://www.seomoz.org/blog/are-exact-match-domains-in-decline" target="_blank" rel="noopener">博客</a>和<a href="http://www.seomoz.org/google-algorithm-change" target="_blank" rel="noopener">指南</a>，甚至<a href="http://dict.cn/from%20the%20ground%20up" target="_blank" rel="noopener">从头开始</a>设计<a href="http://mozcast.com/" target="_blank" rel="noopener">整个项目</a>并基于他们的创意执行。他的影响遍及整个公司，横跨多个团队，和他们一同成长。他通过自己的影响力定义了这个角色，这比其它方式都好。</p><p><a href="https://translate.google.com/#en/zh-CN/on%20the%20flip%20side" target="_blank" rel="noopener">另一方面</a>，优秀的经理人有义务让他们的团队开心、<a href="http://dict.cn/cohesion" target="_blank" rel="noopener">团结</a>、<a href="http://dict.cn/empowerment" target="_blank" rel="noopener">自主</a>，也要负责审查、指导等等。他们发展的越顺利，就越不需要“待在<a href="http://dict.cn/trench" target="_blank" rel="noopener">壕沟</a>里”了。很多情况下，他们只会协助定义战略问题。剩下的定义范围、搜索相关答案、实现和执行统统都交给一线员工来做。一个在 Moz 的好的例子就是 <a href="http://www.seomoz.org/team/samantha" target="_blank" rel="noopener">Samantha Britney</a>。她长期是一个一线员工，但现如今已经成为了经理人，帮助产品团队的几个一线员工，给予他们工作的自主性，通过工具、资源和协助把事做好，并提供作为一个经理人必要的辅导、一对一、回顾和 HR 工作。她的报告中从不会提及任何细枝末节，但总会驱动他们的项目向前。</p><p>基本上，如果你喜欢并且能够把这件事做好，那么你应该做一个一线员工。如果你喜欢 (且擅长) 把自主权交给其他人，帮助他们成长和成功，那么你应该做一个经理人。</p><p>这些一线员工和经理人之间有这样一些<a href="http://dict.cn/nuance" target="_blank" rel="noopener">差别</a>：</p><ul><li>随着一线员工们的发展，他们希望和经理人的职责范围有更多的重叠。对经理人来说恰恰相反——随着他们的发展，他们实际干的活越来越少。</li><li>资深的一线员工的角色更加灵活——他们能够在各种地方工作，并且由于工作得到<a href="http://dict.cn/recognition" target="_blank" rel="noopener">认可</a>，收到的会议和活动邀约就越来越多。资深的经理人相反——他们在办公室的时间更为<a href="http://dict.cn/critical" target="_blank" rel="noopener">关键</a>，所以很少出差，也经常<a href="http://dict.cn/behind-the-scenes" target="_blank" rel="noopener">身居幕后</a> (<a href="http://dict.cn/notable" target="_blank" rel="noopener">很明显</a> CEO 在这方面是一个例外)。</li><li>如果你有很多一线员工却只有很少的经理人，那么你会发现汇报和管理很有挑战。但是如果你有一堆经理人而没几个一线员工，你会<a href="http://dict.cn/horrify" target="_blank" rel="noopener">面临</a>“厨师太多伙计不够了”的问题 (并且这通常意味着你们的组织和文化已经一团糟了)。</li><li>优秀的一线员工有时会发展成为经理人，并因此在新的角色上变得<a href="http://dict.cn/mediocre" target="_blank" rel="noopener">平庸</a>或失败。这绝对是个悲剧。公司不仅失去了一个卓越的一线员工，而且连管理也被搞砸了，因为这会造成大量<a href="http://dict.cn/viral" target="_blank" rel="noopener">传染式</a>的问题。<a href="https://translate.google.com/#en/zh-CN/on%20the%20flip%20side" target="_blank" rel="noopener">而</a>如果一个一线员工<a href="http://dict.cn/underperforming" target="_blank" rel="noopener">表现平平</a>，问题往往不至于这么严重。</li><li><a href="http://dict.cn/compensation" target="_blank" rel="noopener">待遇</a>是个技巧活儿。在我理想的世界里 (对了我们在 Moz 创建的工资范围是跨发展路线的)，一线员工和经理人的级别是<a href="http://dict.cn/roughly" target="_blank" rel="noopener">大致</a><a href="http://dict.cn/equivalent" target="_blank" rel="noopener">等价的</a>。假设在某一条路线上有 7 个级别，那么 level 3 的一线员工可以做 level 3 的经理人的事情。最高级别的一线员工应该能够和 CXO 挣得一样多。</li></ul><p>我和他人分享这些观点时，大部分情况是<a href="http://dict.cn/intuitive" target="_blank" rel="noopener">直观的</a>。我遇到过的最大问题和一个简单的概念有关——战略战术的所有权。有一天一个 Mozzer 同事和我在这方面的看法就不一致。他觉得在 Moz 的历史上，有些团队的经理人掌握着战略和战术的所有权。个人开发者没有定义他们做什么，怎么做，如何衡量，也没有定义执行过程，他们只是接受命令。</p><p>是的这样做也行得通并且这种情况确实发生过。但是我不同意我的同事，这样做相比于，把更大的所有权交给一线员工，让他们决定做什么、何时何地、如何做，让经理人指决定谁来做已经为什么要做，效果不可能一样。<a href="http://dict.cn/Granted" target="_blank" rel="noopener">诚然</a>，很多初级经理人和一线员工之间会具有更大的内容重叠，而很多高级个人开发者会决定谁来做和为什么要做 (如上所述)。但是我强烈的相信，从长期来看，我们应该走这条路。人们的快乐便在此之上。</p><p>当 Daniel Pink 问道<a href="http://www.danpink.com/drive-the-summaries" target="_blank" rel="noopener">“是什么让我们的工作快乐？”</a>时，答案已经很明显 (并且被很多其他学者和不太正式调查者证实)：</p><ol><li>自治——主导我们自己生活的渴望。</li><li>精通——在关键的事情上越做越好的欲望。</li><li>目的——渴望做好比我们自己更重要的事情</li></ol><p>如果个人开发者无法控制自己的工作内容并且能够掌握工作技能，他们中间优秀的人就会离开，去那些提供这种机会的公司。我们将只留下经理人，而且这会很快。</p><p>很奇怪，我是那种一线员工风格的 CEO (也许这并不都是奇怪)。我是一个高级别的一线员工，所以我和经理人有很大的职责重叠，但是我会服务所有的团队、工作和细节。我可能是最直接参与到产品和市场的人，我也经常让这些团队 Mozzer 们像对待资源和工具一样对待我。你让我写篇博客我就会去写，你让我答复一个客户我就会冲上去，你需要聊聊一个项目如何匹配更广泛的目标，以及如何改变你的做法，那就一起聊聊呗。我喜欢我汇报给这些 Moz 员工的感觉——而不是其它方式。我想这件事情永远也不会改变。</p><p>p.s. 我很喜欢 <a href="http://themassesareangry.blogspot.com/2011/05/on-virtues-of-being-individual.html" target="_blank" rel="noopener">Phil Scarr 的这篇文章</a>，它描述了自己从经理人转变为一线员工的经历以及为什么。<a href="http://www.seomoz.org/team/carin" target="_blank" rel="noopener">Carin</a> 从带领着我们的大数据团队，转变为一个产品团队的资深一线员工，我为之感到骄傲。</p><p>p.p.s. 如果我的思路不对 (或者对) 而你也有相关的经验，不妨也留言给我。我一定虚心学习——因为我一直在提醒自己，我是第一次当 CEO </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自：&lt;a href=&quot;https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：作者 Rand 是 Moz 的 CEO，文中反复出现两个词：IC (Individual Contributor) 和 PW (People Wrangler)，分别翻译成了一线员工和经理人。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://everywhereist.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Geraldine&lt;/a&gt; 很喜欢她曾经在 Cranium 的工作 (西雅图的&lt;a href=&quot;http://dict.cn/board%20game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;桌游&lt;/a&gt;初创公司，在 Hasbro 收购他们并&lt;a href=&quot;http://dict.cn/layoffs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;裁员&lt;/a&gt;&lt;a href=&quot;http://dict.cn/prior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;之前&lt;/a&gt;)。她为桌游撰写问题，并为包装盒和营销材料撰写&lt;a href=&quot;http://dict.cn/copy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文案&lt;/a&gt;。她很擅长这个。但是发生了一些奇怪的事情——他们想让她晋升。我记得她晚上回家后&lt;a href=&quot;http://dict.cn/endlessly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;非常的&lt;/a&gt;&lt;a href=&quot;http://dict.cn/fretting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苦恼&lt;/a&gt;。她不想让人们向她汇报。她不想在团队中拥有更大的责任。她只想写写东西。&lt;/p&gt;
&lt;p&gt;这很奇怪。当我们审视一家公司的结构时，很容易发现团队需要很多高质量的一线员工 (IC) 以及少数高质量的&lt;a href=&quot;http://dict.cn/wrangler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;经理人&lt;/a&gt;。然而我们的&lt;a href=&quot;http://dict.cn/corporate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公司&lt;/a&gt;文化和这个世界的“模式”已经让我觉得除非你要带人，否则你的影响力、薪水、利益、职位和自我价值都不会增长。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.urbandictionary.com/define.php?term=I%20call%20bullshit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这都什么乱七八糟的。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我过去写过关于多样化成长轨迹的重要性——&lt;a href=&quot;https://moz.com/rand/whats-the-right-team-structure/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一线员工和经理人&lt;/a&gt;——但是我们最近在 Moz 花了大量的时间碰撞想法，很快会实施一个新的职位/团队的结构，最终付诸实践，我对此充满期待。&lt;/p&gt;
&lt;p&gt;现在我会为一个在其工作岗位上做的很优秀的一线员工表达对管理的兴趣而担心。我担心这种渴望的很&lt;a href=&quot;http://dict.cn/significant&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重要的&lt;/a&gt;&lt;a href=&quot;http://dict.cn/portion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一部分&lt;/a&gt;不源自真正的管理责任感，而是因为他们想要在职业生涯和/或影响力上得到提高，并且认为这是唯一的办法。&lt;/p&gt;
&lt;p&gt;我画了这张图来辅助&lt;a href=&quot;http://dict.cn/illustrate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;说明&lt;/a&gt;两种角色之间的不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://moz.com/rand/wp-content/uploads/2013/04/ics-vs-pws-small.gif&quot; alt=&quot;ics-vs-pws-small&quot;&gt;&lt;br&gt;(&lt;a href=&quot;https://moz.com/rand/wp-content/uploads/2013/04/ics-vs-pws-large.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大图&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何撰写 Git 提交信息</title>
    <link href="https://jinjiang.github.io//blog/git-commit/"/>
    <id>https://jinjiang.github.io//blog/git-commit/</id>
    <published>2017-03-19T19:28:05.000Z</published>
    <updated>2017-08-17T19:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自：<a href="https://chris.beams.io/posts/git-commit/" target="_blank" rel="noopener">https://chris.beams.io/posts/git-commit/</a></p><hr><p><img src="https://imgs.xkcd.com/comics/git_commit.png" alt=""></p><h3 id="介绍：为什么好的提交信息非常重要"><a href="#介绍：为什么好的提交信息非常重要" class="headerlink" title="介绍：为什么好的提交信息非常重要"></a>介绍：为什么好的提交信息非常重要</h3><p>如果你浏览任何 Git 仓库的日志，你可能会发现那些提交信息多少有些<a href="http://dict.cn/mess" target="_blank" rel="noopener">混乱</a>。比如，看看这些我早年提交给 Spring 的<a href="https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams" target="_blank" rel="noopener">精品</a>：</p><pre><code>$ git log --oneline -5 --author cbeams --before &quot;Fri Mar 26 2009&quot;e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)147709f Tweaks to package-info.java files22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils7f96f57 polishing</code></pre><p><a href="http://dict.cn/Yikes" target="_blank" rel="noopener">呀</a>，比较一下这个仓库<a href="https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb" target="_blank" rel="noopener">最近的提交</a>：</p><pre><code>$ git log --oneline -5 --author pwebb --before &quot;Sat Aug 30 2014&quot;5ba3db6 Fix failing CompositePropertySourceTests84564a0 Rework @PropertySource early parsing logice142fd1 Add tests for ImportSelector meta-data887815f Update docbook dependency and generate epubac8326d Polish mockito usage</code></pre><p>你更喜欢读哪个呢？</p><a id="more"></a><p>过去的信息从长度到形式都很多样；最近的信息比较简洁且一致。过去的信息是一般情况下会发生的；最近的信息绝不是<a href="http://dict.cn/by%20accident" target="_blank" rel="noopener">偶然</a>发生。</p><p>虽然很多仓库的日志看起来像是过去的，但也有例外。Linux 内核和 Git 自身就是伟大的例子。再比如 Spring Boot 或其它由 Tim Pope 管理的仓库。</p><p>这些仓库的贡献者知道，对于一个开发同事来说 (其实对未来的<a href="http://dict.cn/selves" target="_blank" rel="noopener">自己</a>也是一样)，一条用心撰写的 Git 提交信息是用来沟通这则改动最好的上下文。一个 diff 会告诉你<em>什么</em>改变了，但是只有提交信息能<a href="http://dict.cn/properly" target="_blank" rel="noopener">正确的</a>告诉你<em>为什么</em>。Peter Hutterer 阐述得非常好：</p><blockquote><p>重建一段代码的上下文是非常费时费力的，这是无法完全避免的。所以我们应该努力尽可能的<a href="http://www.osnews.com/story/19266/WTFs_m" target="_blank" rel="noopener">减少它</a>。提交信息可以帮上这个忙，也正因为此，一个提交信息反应了一名开发者是不是个好的协作者。</p></blockquote><p>如果你对于创建一个伟大的提交信息还没有想过太多，那说明你可能还没有在 <code>git log</code> 及相关的工具上花费太多的时间。这里有一个<a href="http://dict.cn/vicious" target="_blank" rel="noopener">恶性</a>循环：因为提交历史不成体系且不一致，我们就不会花更多的时间使用和关心它。因为它得不到使用和关注，所以它就一直不成体系且不一致。</p><p>但是用心写出来的日志是美丽且实用的。<code>git blame</code>、<code>revert</code>、<code>rebase</code>、<code>log</code>、<code>shortlog</code> 以及其它子命令就是生命的一部分。回顾其他人的提交和 pull requests 变成了值得去做的事情，并且可以快速独立完成。理解最近几个月或几年为什么发生了这些事情不止是可能的并且是<a href="http://dict.cn/efficient" target="_blank" rel="noopener">高效的</a>。</p><p>一个项目的长期成功<a href="http://dict.cn/rest%20on" target="_blank" rel="noopener">靠的是</a>其可维护性，以及一个拥有比项目的日志更强大的工具的维护者。这里值得花时间学习一下如何<a href="http://dict.cn/properly" target="_blank" rel="noopener">正确的</a>考虑它。一开始可能是个<a href="http://dict.cn/hassle" target="_blank" rel="noopener">麻烦</a>的东西很快会变成习惯，并且最终变成一切<a href="http://dict.cn/involved" target="_blank" rel="noopener">投入</a>的自豪和<a href="http://dict.cn/productivity" target="_blank" rel="noopener">产能</a>的源泉。</p><p>在这篇文章中，我只会<a href="http://dict.cn/addressing" target="_blank" rel="noopener">致力于</a>保障一个健康的提交历史的最基本要素：如何撰写一份个人提交信息。这里还有其它重要的实践比如<a href="http://dict.cn/squashing" target="_blank" rel="noopener">压缩</a>提交 (commit squashing) 就不是我在这里想说的。可能会为此<a href="http://dict.cn/subsequent" target="_blank" rel="noopener">再</a>写一篇吧。</p><p>大多数编程语言都建立了良好的编码规约，以<a href="http://dict.cn/constitutes" target="_blank" rel="noopener">形成</a><a href="http://dict.cn/idiomatic" target="_blank" rel="noopener">惯用</a>的风格，比如命名、格式化等。当然在这些编码规约中有一些<a href="http://dict.cn/variations" target="_blank" rel="noopener">差异</a>，但是大多数开发者赞同取其一并养成习惯好过每个人都选择自己的风格而<a href="http://dict.cn/ensues" target="_blank" rel="noopener">发生</a>混乱。</p><p>一个团队的提交日志方法应该是一致的。为了建立一个有用的<a href="http://dict.cn/revision" target="_blank" rel="noopener">修订</a>历史，团队应该首先约定一个提交信息的规约，该规约至少定义以下三方面：</p><p><strong>样式。</strong>标记<a href="http://dict.cn/syntax" target="_blank" rel="noopener">句法</a>、缠绕边距、<a href="http://dict.cn/grammar" target="_blank" rel="noopener">语法</a>、<a href="http://dict.cn/capitalization" target="_blank" rel="noopener">大小写</a>、<a href="http://dict.cn/punctuation" target="_blank" rel="noopener">标点符号</a>。把这些东西都找出来，去除猜测，把规则定的尽量简单可行。最终的产出将会是<a href="http://dict.cn/remarkably" target="_blank" rel="noopener">不同寻常的</a>一致的日志，不只是乐于阅读，实际上也让阅读变成了一种<a href="http://dict.cn/on%20a%20regular%20basis" target="_blank" rel="noopener">习惯</a>。</p><p><strong>内容。</strong>提交信息的正文 (body) (如有) 应该包含什么样的信息？不应该包含什么？</p><p><strong>元数据。</strong>Issue 追踪 ID、pull request 号等信息如何放进来？</p><p>幸运的是，这里有一些已经被良好建立的规约，用来创建<a href="http://dict.cn/idiomatic" target="_blank" rel="noopener">惯用的</a> Git 提交信息。<a href="http://dict.cn/indeed" target="_blank" rel="noopener">事实上</a>，有些规约中很多都是以某种 Git 命令的方式工作的。不需要你重新发明任何东西。只需遵循下面七大法则，你就可以像专家一样进行提交：</p><h3 id="伟大的-Git-提交信息七大法则"><a href="#伟大的-Git-提交信息七大法则" class="headerlink" title="伟大的 Git 提交信息七大法则"></a>伟大的 Git 提交信息七大法则</h3><blockquote><p>注意：<a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="noopener">这些</a> <a href="http://www.git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines" target="_blank" rel="noopener">法则</a> <a href="https://github.com/torvalds/subsurface/blob/master/README#L82-109" target="_blank" rel="noopener">之前</a> <a href="http://who-t.blogspot.co.at/2009/12/on-commit-messages.html" target="_blank" rel="noopener">在别的地方</a> <a href="https://github.com/erlang/otp/wiki/writing-good-commit-messages" target="_blank" rel="noopener">也</a> <a href="https://github.com/spring-projects/spring-framework/blob/30bce7/CONTRIBUTING.md#format-commit-messages" target="_blank" rel="noopener">提到过</a>。</p></blockquote><ol><li>用一个空行把主题和主题隔离开</li><li>把主题行限制在 50 个字符以内</li><li>主题行大写开头</li><li>主题行不必以句号结尾</li><li>在主题行中使用<a href="http://dict.cn/imperative" target="_blank" rel="noopener">祈使句</a></li><li>正文在 72 个字符处折行</li><li>使用正文解释<em>是什么</em>和<em>为什么</em>而不是<em>怎么样</em></li></ol><p>比如：</p><pre><code>Summarize changes in around 50 characters or lessMore detailed explanatory text, if necessary. Wrap it to about 72characters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like `log`, `shortlog`and `rebase` can get confused if you run the two together.Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequences of thischange? Here&apos;s the place to explain them.Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded   by a single space, with blank lines in between, but conventions   vary hereIf you use an issue tracker, put references to them at the bottom,like this:Resolves: #123See also: #456, #789</code></pre><h4 id="1-用一个空行把主题和正文隔离开"><a href="#1-用一个空行把主题和正文隔离开" class="headerlink" title="1. 用一个空行把主题和正文隔离开"></a>1. 用一个空行把主题和正文隔离开</h4><p>在 <code>git commit</code> 的 manpage 手册中写到：</p><blockquote><p>虽然不是必须的，但是你最好以一句少于 50 个字符的话简短概括你的改动，然后空一行，再深入描述。提交信息中空行之上的文本会被当作提交的标题，该标题在 Git 中到处都会用到。比如 Git-format-patch(1) 会把一个提交转换为一封电子邮件，它会把这个标题作为邮件的主题，其余的部分会作为邮件的正文。</p></blockquote><p>首先，不是每一次提交都同时需要一个主题和一段正文。有的时候单独一行就可以了，尤其是当改动很简单没有更多必要的上下文的时候。比如：</p><pre><code>Fix typo in introduction to user guide</code></pre><p>无需说更多；如果读者好奇到底修复了什么 typo，她可以通过诸如 <code>git show</code> 或 <code>git diff</code> 或 <code>git log -p</code> 简单看看改动的内容就可以了。</p><p>如果你是在命令行中提交，则很容易使用 <code>git commit</code> 的 <code>-m</code> 选项：</p><pre><code>$ git commit -m&quot;Fix typo in introduction to user guide&quot;</code></pre><p>然而，当一个提交<a href="http://dict.cn/merits" target="_blank" rel="noopener">值得</a>一些解释和上下文的时候，你需要撰写正文。比如：</p><pre><code>Derezz the master control programMCP turned out to be evil and had become intent on world domination.This commit throws Tron&apos;s disc into MCP (causing its deresolution)and turns it back into a chess game.</code></pre><p>带正文的提交信息并不便于通过 <code>-m</code> 选项来撰写。你最好找一个合适的文本编辑器撰写信息。如果你并没有在命令行中为 Git 设置过编辑器，那么请移步阅读 <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration" target="_blank" rel="noopener">Pro Git 的这个章节</a>。</p><p>当你在任何情况下浏览日志的时候，都会觉得把主题从正文中分离出来是<a href="http://dict.cn/pay%20off" target="_blank" rel="noopener">值得的</a>。这里有一整段日志：</p><pre><code>$ git logcommit 42e769bdf4894310333942ffc5a15151222a87beAuthor: Kevin Flynn &lt;kevin@flynnsarcade.com&gt;Date:   Fri Jan 01 00:00:00 1982 -0200 Derezz the master control program MCP turned out to be evil and had become intent on world domination. This commit throws Tron&apos;s disc into MCP (causing its deresolution) and turns it back into a chess game.</code></pre><p>现在运行 <code>git log --oneline</code>，这个命令只会打印主题行：</p><pre><code>$ git log --oneline42e769 Derezz the master control program</code></pre><p>或者，<code>git shortlog</code>，这个命令会把提交按照用户分组，同样出于<a href="http://dict.cn/concision" target="_blank" rel="noopener">简洁</a>的考虑只会打印主题行：</p><pre><code>$ git shortlogKevin Flynn (1):      Derezz the master control programAlan Bradley (1):      Introduce security program &quot;Tron&quot;Ed Dillinger (3):      Rename chess program to &quot;MCP&quot;      Modify chess program      Upgrade chess programWalter Gibbs (1):      Introduce protoype chess program</code></pre><p>在 Git 里还有一些其它的情况下，会<a href="http://dict.cn/distinction" target="_blank" rel="noopener">区分</a>主题行和正文——但是如果没有它们中间的空行的话是不会<a href="http://dict.cn/properly" target="_blank" rel="noopener">正常</a>工作的。</p><h4 id="2-把主题行限制在-50-个字符以内"><a href="#2-把主题行限制在-50-个字符以内" class="headerlink" title="2. 把主题行限制在 50 个字符以内"></a>2. 把主题行限制在 50 个字符以内</h4><p>50 个字符并不是一个严格的限制，只是个<a href="http://dict.cn/rule%20of%20thumb" target="_blank" rel="noopener">经验之谈</a>。保持主题行的长度以确保它可读且促使作者考虑一下最<a href="http://dict.cn/concise" target="_blank" rel="noopener">简略</a>的表达方式足矣。</p><blockquote><p>提示：如果你做总结很艰难，你可能是一次性提交太多东西了。把原子提交从中剥离出来吧 (每个主题是一个独立的提交)。</p></blockquote><p>GitHub 的 UI 都会提醒这些规约。如果你输入超过 50 个字符的限制，它会警告：</p><p><img src="https://i.imgur.com/zyBU2l6.png" alt="gh1"></p><p>而且会主题行超过 75 个字符的部分会被截断，留下一个省略号：</p><p><img src="https://i.imgur.com/27n9O8y.png" alt="gh2"></p><p>所以奔着 50 个字符去写，但是 72 个字符是底线。</p><h4 id="3-主题行大写开头"><a href="#3-主题行大写开头" class="headerlink" title="3. 主题行大写开头"></a>3. 主题行大写开头</h4><p>如题。比如：</p><ul><li>Accelerate to 88 miles per hour</li></ul><p>而不是：</p><ul><li>accelerate to 88 miles per hour</li></ul><h4 id="4-主题行不必以句号结尾"><a href="#4-主题行不必以句号结尾" class="headerlink" title="4. 主题行不必以句号结尾"></a>4. 主题行不必以句号结尾</h4><p>主题行结尾的标点<a href="http://dict.cn/punctuation" target="_blank" rel="noopener">符号用法</a>不是必要的。而且，当你打算控制在 50 个字符以内时，连空格都是<a href="http://dict.cn/precious" target="_blank" rel="noopener">很宝贵的</a>。比如：</p><ul><li>Open the pod bay doors</li></ul><p>而不是：</p><ul><li>Open the pod bay doors.</li></ul><h4 id="5-在主题行中使用祈使句"><a href="#5-在主题行中使用祈使句" class="headerlink" title="5. 在主题行中使用祈使句"></a>5. 在主题行中使用<a href="http://dict.cn/imperative" target="_blank" rel="noopener">祈使句</a></h4><p><em><a href="http://dict.cn/imperative" target="_blank" rel="noopener">祈使句</a></em>就是指“说起来或写起来像是在发号施令”。举几个例子：</p><ul><li>Clean your room</li><li>Close the door</li><li>Take out the trash</li></ul><p>其实这七大法则的每一条读起来都是<a href="http://dict.cn/imperative" target="_blank" rel="noopener">祈使句</a>的 (“正文在 72 个字符处折行”等)。</p><p><a href="http://dict.cn/imperative" target="_blank" rel="noopener">祈使句</a>听起来有一点粗鲁；这也是我们为什么不常用它的原因。但是这非常适合写在 Git 提交的主题行中。其中一个的原因就是 <strong>Git 本身就是根据你的意志<a href="http://dict.cn/imperative" target="_blank" rel="noopener">命令式</a>的创建一个提交的</strong>。</p><p>例如，使用 <code>git merge</code> 的默认信息读起来是这样的：</p><pre><code>Merge branch &apos;myfeature&apos;</code></pre><p>而用 <code>git revert</code> 的时候是：</p><pre><code>Revert &quot;Add the thing with the stuff&quot;This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d.</code></pre><p>再或者在一个 GitHub pull request 上点击“Merge”按钮时：</p><pre><code>Merge pull request #123 from someuser/somebranch</code></pre><p>所以当你以<a href="http://dict.cn/imperative" target="_blank" rel="noopener">祈使句</a>撰写你的提交信息时，你遵循了 Git 自己内建的规约。比如：</p><ul><li>Refactor subsystem X for readability</li><li>Update getting started documentation</li><li>Remove deprecated methods</li><li>Release version 1.0.0</li></ul><p>这样撰写一开始会觉得有点<a href="http://dict.cn/awkward" target="_blank" rel="noopener">怪怪的</a>。我们更多的在说话的时候使用<a href="http://dict.cn/indicative" target="_blank" rel="noopener">陈述句</a>来陈述事实。这是为什么提交信息经常读起来像：</p><ul><li>Fixed bug with Y</li><li>Changing behavior of X</li></ul><p>有的时候提交信息写起来像是对于其内容的描述：</p><ul><li>More fixes for broken stuff</li><li>Sweet new API methods</li></ul><p>为了避免混淆，这里有一个简单原则，可以用在每一个地方。</p><p><strong>一个 Git 提交的主题行的准确的格式应该始终完全遵循下面的句式：</strong></p><ul><li>If applied, this commit will <em>这里是你的主题行</em></li></ul><p>比如：</p><ul><li>If applied, this commit will <em>refactor subsystem X for readability</em></li><li>If applied, this commit will <em>update getting started documentation</em></li><li>If applied, this commit will <em>remove deprecated methods</em></li><li>If applied, this commit will <em>release version 1.0.0</em></li><li>If applied, this commit will <em>merge pull request #123 from user/branch</em></li></ul><p>注意<a href="http://dict.cn/imperative" target="_blank" rel="noopener">非祈使句</a>在这里别扭的地方：</p><ul><li>If applied, this commit will <em>fixed bug with Y</em></li><li>If applied, this commit will <em>changing behavior of X</em></li><li>If applied, this commit will <em>more fixes for broken stuff</em></li><li>If applied, this commit will <em>sweet new API methods</em></li></ul><blockquote><p>注意：使用祈使句只在主题行中至关重要。当你撰写正文的时候就可以放下这些限制了。</p></blockquote><h4 id="6-正文在-72-个字符处折行"><a href="#6-正文在-72-个字符处折行" class="headerlink" title="6. 正文在 72 个字符处折行"></a>6. 正文在 72 个字符处折行</h4><p>Git 不会自动给文本折行。当你为一个提交撰写消息正文的时候，你必须意识到它正确的边距，并且手动折行。</p><p>这里推荐在 72 个字符处折行，这样 Git 有足够的空间，即便缩进文本也可以保证所有东西在 80 个字符以内。</p><p>一个好的文本编辑器是可以帮上忙的。比如在 Vim 中配置在 Git 提交的 72 个字符处折行非常容易。然而传统的 IDE 在给提交信息文本折行方面提供的智能支持<a href="http://dict.cn/terrible" target="_blank" rel="noopener">很糟糕</a> (尽管 IntelliJ IDEA 在最近的版本中终于在这方面做得好一些了)。</p><h4 id="7-使用正文解释是什么和为什么而不是怎么样"><a href="#7-使用正文解释是什么和为什么而不是怎么样" class="headerlink" title="7. 使用正文解释是什么和为什么而不是怎么样"></a>7. 使用正文解释是什么和为什么而不是怎么样</h4><p>这个<a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6" target="_blank" rel="noopener">来自比特币核心的提交</a>是一个非常好的解释改动是什么和为什么的例子：</p><pre><code>commit eb0b56b19017ab5c16c745e6da39c53126924ed6Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;Date:   Fri Aug 1 22:57:55 2014 +0200   Simplify serialize.h&apos;s exception handling   Remove the &apos;state&apos; and &apos;exceptmask&apos; from serialize.h&apos;s stream   implementations, as well as related methods.   As exceptmask always included &apos;failbit&apos;, and setstate was always   called with bits = failbit, all it did was immediately raise an   exception. Get rid of those variables, and replace the setstate   with direct exception throwing (which also removes some dead   code).   As a result, good() is never reached after a failure (there are   only 2 calls, one of which is in tests), and can just be replaced   by !eof().   fail(), clear(n) and exceptions() are just never called. Delete   them.</code></pre><p>看一眼<a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6" target="_blank" rel="noopener">完整的 diff</a>，想一下作者此时此刻通过提供这样的上下文为同事以及未来的提交者节省了多少时间。如果他不这样做，这些信息可能永远找不回来了。</p><p>在很多情况下，你可以<a href="http://dict.cn/leave%20out" target="_blank" rel="noopener">忽略</a>这个改动发生时的各种细节。从这个角度看，代码自己会说话 (如果代码很复杂以至于需要长篇大论的解释，那也是代码注释该做的事情)。请首先专注于弄清你产生这个改动的理由——改动前的工作方式，改动后的工作方式 (以及这样做哪里不对)，以及为什么你决定以这样的方式解决问题。</p><p>你将来某一天维护它的时候也许会感激今天的你！</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="学着爱上命令行。远离-IDE。"><a href="#学着爱上命令行。远离-IDE。" class="headerlink" title="学着爱上命令行。远离 IDE。"></a>学着爱上命令行。远离 IDE。</h4><p>[和 Git 子命令同样多的原因][For-as-many-reasons-at-there-are-Git-subcommands]，拥抱命令行是<a href="http://dict.cn/wise" target="_blank" rel="noopener">明智</a>的。Git 是<a href="http://dict.cn/insanely" target="_blank" rel="noopener">超级</a>强大的；IDE 也一样，但是套路不同。我每天都使用 IDE (IntelliJ IDEA) 也用过<a href="http://dict.cn/extensively" target="_blank" rel="noopener">很多</a>其它的 (Eclipse)，但是我从未见到 IDE 对 Git 的集成能够配得上命令行的易用和强大 (一旦你意识到这一点)。</p><p>某些 Git 相关的 IDE 功能是<a href="http://dict.cn/invaluable" target="_blank" rel="noopener">非常宝贵的</a>，比如当你删除一个文件时调用 <code>git rm</code>、当你重命名一个文件时完成相应的 <code>git</code> 命令。但是当你尝试提交、合并、rebase、或通过 IDE 做<a href="http://dict.cn/sophisticated" target="_blank" rel="noopener">复杂的</a>历史分析时，事情就<a href="http://dict.cn/fall%20apart" target="_blank" rel="noopener">分崩离析</a>了。</p><p>当你想<a href="http://dict.cn/wielding" target="_blank" rel="noopener">发挥出</a> Git 全部的能量的时候，命令行始终是不二之选。</p><p>记住不论你是用的是 Bash 还是 Z shell，都有 <a href="http://git-scm.com/book/en/Git-Basics-Tips-and-Tricks" target="_blank" rel="noopener">tab 补全脚本</a>减轻忘记子命令和开关的痛苦。</p><h4 id="阅读-Pro-Git"><a href="#阅读-Pro-Git" class="headerlink" title="阅读 Pro Git"></a>阅读 Pro Git</h4><p><a href="http://git-scm.com/book" target="_blank" rel="noopener">Pro Git</a> 这本书已经可以免费在线阅读，这本书非常棒。<a href="http://dict.cn/take%20advantage" target="_blank" rel="noopener">用好它吧</a>！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自：&lt;a href=&quot;https://chris.beams.io/posts/git-commit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://chris.beams.io/posts/git-commit/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/git_commit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍：为什么好的提交信息非常重要&quot;&gt;&lt;a href=&quot;#介绍：为什么好的提交信息非常重要&quot; class=&quot;headerlink&quot; title=&quot;介绍：为什么好的提交信息非常重要&quot;&gt;&lt;/a&gt;介绍：为什么好的提交信息非常重要&lt;/h3&gt;&lt;p&gt;如果你浏览任何 Git 仓库的日志，你可能会发现那些提交信息多少有些&lt;a href=&quot;http://dict.cn/mess&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;混乱&lt;/a&gt;。比如，看看这些我早年提交给 Spring 的&lt;a href=&quot;https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;精品&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --oneline -5 --author cbeams --before &amp;quot;Fri Mar 26 2009&amp;quot;

e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.
2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)
147709f Tweaks to package-info.java files
22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils
7f96f57 polishing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://dict.cn/Yikes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;呀&lt;/a&gt;，比较一下这个仓库&lt;a href=&quot;https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最近的提交&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --oneline -5 --author pwebb --before &amp;quot;Sat Aug 30 2014&amp;quot;

5ba3db6 Fix failing CompositePropertySourceTests
84564a0 Rework @PropertySource early parsing logic
e142fd1 Add tests for ImportSelector meta-data
887815f Update docbook dependency and generate epub
ac8326d Polish mockito usage
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你更喜欢读哪个呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C 程序的原则</title>
    <link href="https://jinjiang.github.io//blog/principles-for-c-programming/"/>
    <id>https://jinjiang.github.io//blog/principles-for-c-programming/</id>
    <published>2017-03-18T20:48:07.000Z</published>
    <updated>2017-03-18T21:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照 Doug Gwyn 的话说：“Unix 不会阻止你做愚蠢的事情，因为那会同样阻止你做聪明的事情”。C 是一个非常强大的工具，但使用它的时候需要非常小心和<a href="http://dict.cn/discipline" target="_blank" rel="noopener">自律</a>。学习这些纪律是绝对值得的，因为 C 是所有程序语言中最优秀的。一个自律的 C 程序员将会……</p><p><strong>喜欢可维护性</strong>。不要在不必要的地方自作聪明。取而代之的是，找出最简单最易懂的满足需求的方案。诸如性能之类考量是放在第二位的。你应该为你的代码做一个性能预算，并自在的支配它。</p><p>随着你对这门语言越来越<a href="http://dict.cn/proficient" target="_blank" rel="noopener">了解</a>，掌握了越来越多能够从中获益的特性，你也应该学会什么时候不能使用它们。相比用到了很多新奇的方式去解决问题，易于<a href="http://dict.cn/novice" target="_blank" rel="noopener">新手</a>理解是更重要的。最好是让一个新手理解你的代码并从中有所收获。像你<a href="http://dict.cn/circa" target="_blank" rel="noopener">大概</a>去年就在维护它一样去撰写代码。</p><p><strong>避免使用魔法</strong>。不要使用宏 (macros)——尽管用它定义常量是没问题的。不要使用 typedef 来隐藏指针或回避撰写“结构”。避免撰写复杂的抽象。保持你的构建系统简单透明。不要因为一个愚蠢的 hacky 的<a href="http://dict.cn/crap" target="_blank" rel="noopener">废物</a>解决问题的方式酷炫就使用它。你的代码在行为<a href="http://dict.cn/underlying" target="_blank" rel="noopener">之下</a>应该是明显的，甚至不需要上下文。</p><p>C 最大的优势之一就是透明和简单。这应该被信奉，而不是被<a href="http://dict.cn/subverted" target="_blank" rel="noopener">颠覆</a>。但是 C 的优良传统是给你足够的空间施展自己，所以你可以为了一些魔术般的目的使用它。但最好还是不要这样，做个<a href="http://dict.cn/muggle" target="_blank" rel="noopener">麻瓜</a>挺好的。</p><p><strong>辨识并回避危险的模式</strong>。不要使用固定尺寸的 buffers (有人指出这种说法并不是完全正确。我之前打草稿的时候提到了这些，但还是删掉了)——始终计算你需要分配的空间。阅读你使用的函数的 man 手册并掌握他的成功有出错模式。立刻把不安全的用户输入转换为<a href="http://dict.cn/sanitized" target="_blank" rel="noopener">干净</a>的 C 结构。如果你之后会把这些数据展现给用户，那么尽可能把 C 结构保持到最后。要学会在使用例如 strcat 的敏感函数时多加留意。</p><p>撰写 C 有的时候像握着一把枪。枪是很重要的工具，但是和枪有关的事故都是非常糟糕的。你对待枪要非常小心：不要用枪指着任何你喜爱的东西，要有好的用枪<a href="http://dict.cn/discipline" target="_blank" rel="noopener">纪律</a>，把它当作始终上膛一样谨慎。而就像枪善于拿来打孔一样，C 也善于用来撰写内核。</p><p><strong>用心组织代码。</strong>永远不要把代码写到 header 里。永远不要使用 <code>inline</code> 关键字。把独立的东西分开写成不同的文件。<a href="http://dict.cn/liberally" target="_blank" rel="noopener">大量</a>使用静态方法组织你的逻辑。用一套编码规范让一切都有足够的<a href="http://dict.cn/breathing%20room" target="_blank" rel="noopener">空间</a>且易于阅读。当目的<a href="http://dict.cn/self-evident" target="_blank" rel="noopener">显而易见</a>的情况下使用单字符变量名，反之则使用<a href="http://dict.cn/descriptive" target="_blank" rel="noopener">描述性</a>的变量名。</p><p>我喜欢把我的代码组织成目录，每个目录实现一组函数，每个函数有属于自己的文件。这些文件通常会包含很多静态函数，但是它们全部用于组织这个文件所要实现的行为。写一个 header 允许这个模块被外部访问。并使用 Linux 内核编码规范，<a href="http://dict.cn/god%20dammit" target="_blank" rel="noopener">该死</a>。</p><p><strong>只使用标准的特性</strong>。不要把平台假设为 Linux。不要把编译器假设为 gcc。不要把 libc 假设为 glibc。不要把架构假设为 x86 的。不要把核心工具假设为 GNU。不要定义 <code>_GNU_SOURCE</code>。</p><p>如果你一定要使用平台相关的特性，为这样的特性描述一个接口，然后撰写各自平台相关的支持代码。在任何<a href="http://dict.cn/circumstances" target="_blank" rel="noopener">情况</a>下都不要使用 gcc 扩展或 glibc 扩展。GNU 是<a href="http://dict.cn/blight" target="_blank" rel="noopener">枯萎的</a>，不要让它<a href="http://dict.cn/infect" target="_blank" rel="noopener">传染</a>到你的代码。</p><p><strong>使用<a href="http://dict.cn/discipline" target="_blank" rel="noopener">严谨</a>的工作流</strong>。也要有严谨的版本控制方法。撰写提交记录的时候要<a href="http://dict.cn/thoughtful" target="_blank" rel="noopener">用心</a>——在第一行简短解释变动，然后在扩展提交记录中加上改变它的<a href="http://dict.cn/justification" target="_blank" rel="noopener">理由</a>。在 feature 分支上工作要明确定义目标，不要包含和这个目标不相关的改动。不要害怕在 rebase 时编辑你的分支的历史，它会让你的改动展示得更清晰。</p><p>当你稍后不得不回退你的代码时，你将会感激你之前详尽撰写的提交记录。其他人和你的代码互动时也同样会心存感激。当你看到一些愚蠢的代码时，也可以知道这个<a href="http://dict.cn/bastard" target="_blank" rel="noopener">白痴</a>当时是怎么想的，尤其是当这个<a href="http://dict.cn/bastard" target="_blank" rel="noopener">白痴</a>是你自己的时候。</p><p><strong>严格测试和<a href="http://dict.cn/review" target="_blank" rel="noopener">回顾</a></strong>。找出你的改动可能会经过的代码路径。测试每条路径的行为是正确的。给它不正确的输入。给它“永远不可能发生”的输入。对<a href="http://dict.cn/error-prone" target="_blank" rel="noopener">有错误倾向</a>的模式格外小心。寻找可以简化代码的地方并让过程变得更清晰。</p><p>接下来，把你的改动交给另外一个人进行<a href="http://dict.cn/review" target="_blank" rel="noopener">回顾</a>。这个人应该运用相同的程序并签署你的改动。而且<a href="http://dict.cn/review" target="_blank" rel="noopener">回顾</a>要<a href="http://dict.cn/discipline" target="_blank" rel="noopener">严格</a>，标准始终如一。<a href="http://dict.cn/review" target="_blank" rel="noopener">回顾</a>的时候应该想着，如果由于这些代码出了问题，自己会<a href="http://dict.cn/be%20your%20ass%20on%20the%20line" target="_blank" rel="noopener">感到耻辱</a>。</p><p><strong>从错误中学习</strong>。首先，修复 bug。然后，修复实际的 bug：你的流程允许里这个错误的发生。拉<a href="http://dict.cn/review" target="_blank" rel="noopener">回顾</a>你代码的人讨论——这是你们共同的过错。严格的检查撰写、<a href="http://dict.cn/review" target="_blank" rel="noopener">回顾</a>和部署这些代码的流程，找出<a href="http://dict.cn/root%20cause" target="_blank" rel="noopener">根源</a>所在。</p><p>解决方案可以简单，比如把 strcat 加入到你的触发“认真回顾”<a href="http://dict.cn/reflex" target="_blank" rel="noopener">条件反射</a>的函数列表。它可以通过电脑进行静态分析，帮你检测到这个问题。可能这些代码需要<a href="http://dict.cn/refactored" target="_blank" rel="noopener">重构</a>，这样找出问题变得简单容易。疏于避免未来的<a href="http://dict.cn/fuck-up" target="_blank" rel="noopener">错误</a>才是真的<a href="http://dict.cn/fuck-up" target="_blank" rel="noopener">大错</a>。</p><hr><p>重要的是记住规则就是用来打破的。可能有些情况下，不被鼓励的行为是有用的，被鼓励的行为是应该<a href="http://dict.cn/disregarded" target="_blank" rel="noopener">被忽视的</a>。你应该<a href="http://dict.cn/strive" target="_blank" rel="noopener">力争</a>把这些情况当作例外而不是<a href="http://dict.cn/norm" target="_blank" rel="noopener">常态</a>，并当它们发生时仔细的<a href="http://dict.cn/justify" target="_blank" rel="noopener">证明</a>它们。</p><p>C 是狗屎。我爱它，并希望更多的人可以学到我做事的方式。祝好运！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;按照 Doug Gwyn 的话说：“Unix 不会阻止你做愚蠢的事情，因为那会同样阻止你做聪明的事情”。C 是一个非常强大的工具，但使用它的时候需要非常小心和&lt;a href=&quot;http://dict.cn/discipline&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue 2.0 来了！</title>
    <link href="https://jinjiang.github.io//blog/vue-2-is-here/"/>
    <id>https://jinjiang.github.io//blog/vue-2-is-here/</id>
    <published>2016-10-01T04:45:09.000Z</published>
    <updated>2017-07-31T19:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于发布了！</p><p>原文：<a href="https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x" target="_blank" rel="noopener">https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x</a></p><p>今天我非常兴奋的官宣 Vue.js 2.0 的发布：Ghost in the Shell。历经 8 个 alpha 版本、8 个 beta 版本和 8 个 rc 版本 (矮油好巧！)，Vue.js 2.0 已经为生产环境准备好了！我们的官方教程 <a href="http://vuejs.org/guide/" target="_blank" rel="noopener">vuejs.org/guide</a> 也已经全面更新。</p><p>2.0 的工作自今年 4 月启动以来，<a href="https://github.com/orgs/vuejs/people" target="_blank" rel="noopener">核心团队</a>为 API 设计、bugfix、文档、类型声明做出了很重要的贡献，社区中的同学们也反馈了很多有价值的 API 建议——在此为每一位参与者致以大大的感谢！</p><a id="more"></a><h3 id="2-0-有哪些新东西"><a href="#2-0-有哪些新东西" class="headerlink" title="2.0 有哪些新东西"></a>2.0 有哪些新东西</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*Lu6OJiraJYShl4aBppoh3w.png" alt="基于第三方 benchmark，数值越低越好"></p><p>基于<a href="http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html" target="_blank" rel="noopener">第三方 benchmark</a>，数值越低越好</p><p>2.0 用一个 fork 自 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a> 的轻量 Virtual DOM 实现对渲染层进行了重写。在其上层，Vue 的模板编译器能够在编译时做一些智能的优化处理，例如分析并提炼出静态子树以避免界面重绘时不必要的比对。新的渲染层较之 v1 带来了巨大的性能提升，也让 Vue 2.0 成为了最快速的框架之一。除此之外，它把你在优化方面需要做的努力降到了最低，因为 Vue 的响应系统能够在巨大而且复杂的组件树中精准的判断其中需要被重绘的那部分。</p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*xV2_bx4eWC9RXiBZjeAMrw.png" alt=""></p><p>还有个值得一提的地方，就是 2.0 的 runtime-only 包大小 min+gzip 过后只有 16kb，即便把 <em>vue-router</em> 和 <em>vuex</em> 都包含进去也只有 26kb，和 v1 核心的包大小相当！</p><h4 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h4><p>尽管渲染层全面更新，Vue 2.0 兼容了绝大部分的 1.0 模板语法，仅废弃掉了其中的一小部分。这些模板在背后被编译成了 Virtual DOM 渲染函数，但是如果用户需要更复杂的 JavaScript，也可以选择在其中直接撰写渲染函数。同时我们为喜欢 JSX 的同学提供了<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener">支持选项</a></p><p>渲染函数使得这种基于组件的开发模式变得异常强大，并打开了各种可能性——比如现在新的 transition 系统就是完全基于组件的，内部由渲染函数实现。</p><h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><p>Vue 2.0 支持服务端渲染 (SSR)，并且是<a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#rendererrendertostreamvm" target="_blank" rel="noopener">流式的</a>，可以做<a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#component-caching" target="_blank" rel="noopener">组件级的缓存</a>，这使得极速渲染成为可能。同时，<em>vue-router</em> 和 <em>vuex</em> 2.0 也都支持了可以通用路由和客户端状态“hydration”的服务端渲染。你可以通过 <a href="https://github.com/vuejs/vue-hackernews-2.0/" target="_blank" rel="noopener">vue-hackernews-2.0 的 demo app</a> 了解到它们是如何协同工作的。</p><h3 id="辅助库"><a href="#辅助库" class="headerlink" title="辅助库"></a>辅助库</h3><p>官方支持的库和工具——<em>vue-router</em>、<em>vuex</em>、<em>vue-loader</em> 和 <em>vueify</em>——都已经升级并支持 2.0 了。<strong>vue-cli 现在已经默认生成 2.0 的脚手架了。</strong></p><p>特别之处在于，<em>vue-router</em> 和 <em>vuex</em> 在它们的 2.0 版本中都已经有了很多改进：</p><p><strong>vue-router</strong></p><ul><li>支持多命名的 <code>&lt;router-view&gt;</code></li><li>通过 <code>&lt;router-link&gt;</code> 组件改进了导航功能</li><li>简化了导航的 hooks API</li><li>可定制的滚动行为控制</li><li><a href="https://github.com/vuejs/vue-router/tree/dev/examples" target="_blank" rel="noopener">更多复杂示例</a></li></ul><p><strong>vuex</strong></p><ul><li>简化了组件内的用法</li><li>通过改进 modules API 提供更好的代码组织方式</li><li>可聚合的异步 actions</li></ul><p>它们各自的 2.0 文档里有更多的细节：</p><ul><li><a href="http://router.vuejs.org/" target="_blank" rel="noopener">http://router.vuejs.org/</a></li><li><a href="http://vuex.vuejs.org/" target="_blank" rel="noopener">http://vuex.vuejs.org/</a></li></ul><h4 id="社区项目"><a href="#社区项目" class="headerlink" title="社区项目"></a>社区项目</h4><p>中国最大的在线订餐平台饿了么的<a href="https://github.com/ElemeFE/" target="_blank" rel="noopener">团队</a>已经基于 Vue 2.0 构建了<a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">一套完整的桌面 UI 组件库</a>。不过还没有英文文档，但是他们正在为此而努力！</p><p>很多其他社区的项目也都在为 2.0 做兼容——请移步到 <a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">awesome-vue</a> 搜索关键字“2.0”。</p><h3 id="从-1-0-迁移"><a href="#从-1-0-迁移" class="headerlink" title="从 1.0 迁移"></a>从 1.0 迁移</h3><p>如果你是一个 Vue 的新同学，现在就可以“无脑”使用 Vue 2.0 了。最大的问题其实是目前 1.0 的用户如何迁移到新的版本。</p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*157Ly5X6gx0C2CIvsMaNog.png" alt=""></p><p>为了帮助大家完成迁移，团队已经在配合 <a href="https://github.com/vuejs/vue-migration-helper" target="_blank" rel="noopener">CLI 迁移辅助工具</a>制作<a href="http://vuejs.org/guide/migration.html" target="_blank" rel="noopener">非常详实的迁移教程</a>。这个工具不一定捕获每一处被废弃的东西，但相信能帮你开个好头。</p><h3 id="One-More-Thing……"><a href="#One-More-Thing……" class="headerlink" title="One More Thing……"></a>One More Thing……</h3><p>中国最大的电商公司阿里巴巴的工程师们已经发起了一个叫做 <a href="https://github.com/alibaba/weex" target="_blank" rel="noopener">Weex</a> 的项目，通过 Vue-inspired 语法在移动端渲染 native UI 组件。但是很快，“Vue-inspired” 将会成为 “Vue-powered”——我们已经启动了官方合作，让 Vue 2.0 真正成为 Weex 的 JavaScript 运行时框架。这让用户能够撰写横跨 Web、iOS 和 Android 的通用 Vue 组件！我们的合作才刚刚开始，这将会是 2.0 发布后未来我们专注的重点，请大家拭目以待！</p><p>Vue 从一个不起眼的 side project 开始如今已经有了长足的发展。今天它已经是<a href="https://www.patreon.com/evanyou" target="_blank" rel="noopener">社区资助的</a>，<a href="https://www.quora.com/How-popular-is-VueJS-in-the-industry/answer/Evan-You-3?__snid3__=365957938&amp;__nsrc__=2&amp;__filter__" target="_blank" rel="noopener">被实际广泛认可的</a>，并且根据 <a href="http://stats.js.org/" target="_blank" rel="noopener">stats.js.org</a> 统计在所有 JavaScript 库中增势最强劲的一个。我们相信 2.0 会走得更远。这是 Vue 自启动以来最大的一次更新，我们期待大家用 Vue 创造出更多好产品！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于发布了！&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我非常兴奋的官宣 Vue.js 2.0 的发布：Ghost in the Shell。历经 8 个 alpha 版本、8 个 beta 版本和 8 个 rc 版本 (矮油好巧！)，Vue.js 2.0 已经为生产环境准备好了！我们的官方教程 &lt;a href=&quot;http://vuejs.org/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vuejs.org/guide&lt;/a&gt; 也已经全面更新。&lt;/p&gt;
&lt;p&gt;2.0 的工作自今年 4 月启动以来，&lt;a href=&quot;https://github.com/orgs/vuejs/people&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;核心团队&lt;/a&gt;为 API 设计、bugfix、文档、类型声明做出了很重要的贡献，社区中的同学们也反馈了很多有价值的 API 建议——在此为每一位参与者致以大大的感谢！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【整理】Vue 2.0 自 beta 1 到 beta 4 以来的主要更新</title>
    <link href="https://jinjiang.github.io//blog/vue-2-from-beta-1-to-beta-4/"/>
    <id>https://jinjiang.github.io//blog/vue-2-from-beta-1-to-beta-4/</id>
    <published>2016-07-27T21:33:05.000Z</published>
    <updated>2017-07-31T19:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容来自 <a href="https://github.com/vuejs/vue/releases" target="_blank" rel="noopener">https://github.com/vuejs/vue/releases</a></p><p>之前 <a href="http://jiongks.name/blog/announcing-vue-2/" target="_blank" rel="noopener">Vue 2.0 发布技术预览版</a> 到现在差不多三个月了，之前写过一篇简单的 <a href="http://jiongks.name/blog/code-review-for-vue-next/" target="_blank" rel="noopener">code review</a>，如今三个月过去了，Vue 2.0 在这个<a href="http://jiongks.name/blog/a-big-map-to-intro-vue-next/" target="_blank" rel="noopener">基础</a>之上又带来了不少更新，这里汇总 beta 以来 (最新的版本是 beta 4) 的主要更新，大家随意学习感受一下</p><h3 id="alpha-和-beta-版本的侧重点会有所不同"><a href="#alpha-和-beta-版本的侧重点会有所不同" class="headerlink" title="alpha 和 beta 版本的侧重点会有所不同"></a>alpha 和 beta 版本的侧重点会有所不同</h3><p>首先 Vue 2.0 对 alpha、beta 有自己的理解和设定：alpha 版本旨在完善 API、考虑所需的特性；而来到 beta 版则会对未来的正式发布进行充分的“消化”，比如提前进行一些必要的 breaking change，增强框架的稳定性、完善文档和周边工具 (如 vue-router 2.0 等)</p><h3 id="最后的几个-alpha-版本主要更新"><a href="#最后的几个-alpha-版本主要更新" class="headerlink" title="最后的几个 alpha 版本主要更新"></a>最后的几个 alpha 版本主要更新</h3><p>Vue 本身的语法基础这里就不多赘述了，网上有很多资料可以查阅，我们已经假定你比较熟悉 Vue 并对 2.0 的理念和技术预览版的状态有一定的了解。</p><a id="more"></a><h4 id="alpha-5"><a href="#alpha-5" class="headerlink" title="alpha 5"></a>alpha 5</h4><ol><li>ref 的写法由 <code>&lt;comp v-ref:foo&gt;</code> 变成了 <code>&lt;comp ref=&quot;foo&quot;&gt;</code>，更加简单，同时动态数据的写法是 <code>&lt;comp :ref=&quot;x&quot;&gt;</code></li><li><p>支持 functional components，这个特性蛮酷的，可以把一个组件的生成过程完全变成一个高度自定义的函数执行过程，比如：</p><p> Vue.component(‘name’, {</p><pre><code>functional: true,props: [&apos;x&apos;],render: (h, props, children) {    return h(props.tag, null, children)}</code></pre><p> })</p></li></ol><p>你可以在 <code>render()</code> 函数里写各种特殊的逻辑，这样标签的含义和能力都得到了非常大的扩展，在后续的几次更新中，你马上会感受到一些 functional components 的威力</p><p>另外剧透一下，<code>h</code> 方法里的第二个参数如果是 <code>null</code> 就可以省略，这个改动出现在了 beta 1</p><h4 id="alpha-6"><a href="#alpha-6" class="headerlink" title="alpha 6"></a>alpha 6</h4><p>可以设置特殊的 keyCode，比如 <code>Vue.config.keyCodes.a = 65</code>，然后你就可以写 <code>&lt;input @keyup.a=&quot;aPressed&quot;&gt;</code> 了</p><h4 id="alpha7"><a href="#alpha7" class="headerlink" title="alpha7"></a>alpha7</h4><ol><li>一个组件的生命周期名由 <code>init</code> 改成了 <code>beforeCreated</code> (大家可以在 Vuex 的源码里看到对应的改变哦)</li><li><code>Vue.transition</code> 的 hook 支持第二个参数，把 vm 传递进去</li></ol><p>如：</p><pre><code>Vue.transition(&apos;name&apos;, {    onEnter (el, vm) {        ...    }})</code></pre><h3 id="Beta-1-Beta-4"><a href="#Beta-1-Beta-4" class="headerlink" title="Beta 1 ~ Beta 4"></a>Beta 1 ~ Beta 4</h3><h4 id="beta-1"><a href="#beta-1" class="headerlink" title="beta 1"></a>beta 1</h4><ol><li>自定义 directive 里 <code>update</code> 的触发时机发生了变化，由于 functional component 等概念的引入，一个 directive 的变更的颗粒度也不完全是 directive 本身引起的，所以这里做了一个更具有通用性的调整；同时 hook 名 <code>postupdate</code> 也相应的更名为 <code>componentUpdated</code>——如果你想让 <code>update</code> 保持原有的触发时机，可以加入一句 <code>binding.value !== binding.oldValue</code> 即可。</li><li><code>Vue.traisition</code> 的 hook 名做了简化<ul><li><code>onEnter</code> -&gt; <code>enter</code></li><li><code>onLeave</code> -&gt; <code>leave</code></li></ul></li><li>server-side rendering<ul><li><code>server.getCacheKey</code> 更名为 <code>serverCacheKey</code>，避免多一层结构嵌套</li><li><code>createRenderer</code>/<code>createBundleRenderer</code> 方法不会强制应用 <code>lru-cache</code>，而是开发者手动选择</li></ul></li></ol><h4 id="beta-2"><a href="#beta-2" class="headerlink" title="beta 2"></a>beta 2</h4><p><code>&lt;transition&gt;</code> 标签来了！</p><p>其实这个玩意儿我之前在 polymer 等其他框架里也见到过，不过看到 Vue 的语法设计，还是觉得巧妙而简洁：</p><pre><code>&lt;transition&gt;    &lt;div v-if=&quot;...&quot;&gt;...&lt;/div&gt;&lt;/traisition&gt;&lt;transition-group tag=&quot;ul&quot;&gt;    &lt;li v-for=&quot;...&quot;&gt;...&lt;/li&gt;&lt;/traisition-group&gt;</code></pre><p>更牛掰的在这里，还记得 functional components 吧，你今天可以这样抽象一个动画效果的标签：</p><pre><code>Vue.component(&apos;fade&apos;, {    functional: true,    render (h, children) {        return h(&apos;transition&apos;, {            props: {...},            on: {                beforeEnter,                afterEnter            }        }, children)    }})</code></pre><p>然后</p><pre><code>&lt;fade&gt;...&lt;/fade&gt;</code></pre><p>就可以实现高度自定义的动画效果了，这个我个人觉得是非常赞的设计和实现！</p><h4 id="beta-3"><a href="#beta-3" class="headerlink" title="beta 3"></a>beta 3</h4><ol><li>支持在自定义组件中使用原生事件。因为在 Vue 2.0 的设计中，自定义组件上是不能绑定原生事件的，自定义组件上的事件绑定被默认理解为组件的自定义事件，而不是原生事件。针对这个问题我很早就提了 <a href="https://github.com/vuejs/vue/issues/2942" target="_blank" rel="noopener">issue</a> 当时小右提出了一个新的语法设计，就是 <code>&lt;comp @click.native=&quot;...&quot;&gt;&lt;/comp&gt;</code>，beta 3 的时候终于看到它被实现了，嘿嘿，有点小激动</li><li>支持两种语法 <code>&lt;div :xxx.prop=&quot;x&quot;&gt;</code> 和 <code>&lt;div v-bind:prop=&quot;{ xxx: x }&quot;&gt;</code> 来对 DOM 的 property 进行绑定，最近我自己也在思考一些在 virtual-DOM 上支持 properties 而不只是 attributes 的想法，这个设计让我也多了一些新的思路。</li></ol><h4 id="beta-4"><a href="#beta-4" class="headerlink" title="beta 4"></a>beta 4</h4><p>2 天前发布的，其实这个版本以 bugfix 为主</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是近期 Vue 2.0 的一些更新，让我自己比较兴奋的主要是 functional component 以及基于这个设计的 <code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 标签和自定义 transition 标签的能力拓展，还有就是久违的 <code>&lt;comp @click.native=&quot;...&quot;&gt;&lt;/comp&gt;</code></p><p>最后希望大家可以多多试用，有更大兴趣的可以多多学习 Vue 的源码！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容来自 &lt;a href=&quot;https://github.com/vuejs/vue/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/vuejs/vue/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前 &lt;a href=&quot;http://jiongks.name/blog/announcing-vue-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue 2.0 发布技术预览版&lt;/a&gt; 到现在差不多三个月了，之前写过一篇简单的 &lt;a href=&quot;http://jiongks.name/blog/code-review-for-vue-next/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code review&lt;/a&gt;，如今三个月过去了，Vue 2.0 在这个&lt;a href=&quot;http://jiongks.name/blog/a-big-map-to-intro-vue-next/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基础&lt;/a&gt;之上又带来了不少更新，这里汇总 beta 以来 (最新的版本是 beta 4) 的主要更新，大家随意学习感受一下&lt;/p&gt;
&lt;h3 id=&quot;alpha-和-beta-版本的侧重点会有所不同&quot;&gt;&lt;a href=&quot;#alpha-和-beta-版本的侧重点会有所不同&quot; class=&quot;headerlink&quot; title=&quot;alpha 和 beta 版本的侧重点会有所不同&quot;&gt;&lt;/a&gt;alpha 和 beta 版本的侧重点会有所不同&lt;/h3&gt;&lt;p&gt;首先 Vue 2.0 对 alpha、beta 有自己的理解和设定：alpha 版本旨在完善 API、考虑所需的特性；而来到 beta 版则会对未来的正式发布进行充分的“消化”，比如提前进行一些必要的 breaking change，增强框架的稳定性、完善文档和周边工具 (如 vue-router 2.0 等)&lt;/p&gt;
&lt;h3 id=&quot;最后的几个-alpha-版本主要更新&quot;&gt;&lt;a href=&quot;#最后的几个-alpha-版本主要更新&quot; class=&quot;headerlink&quot; title=&quot;最后的几个 alpha 版本主要更新&quot;&gt;&lt;/a&gt;最后的几个 alpha 版本主要更新&lt;/h3&gt;&lt;p&gt;Vue 本身的语法基础这里就不多赘述了，网上有很多资料可以查阅，我们已经假定你比较熟悉 Vue 并对 2.0 的理念和技术预览版的状态有一定的了解。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过一张图走进 Vue 2.0</title>
    <link href="https://jinjiang.github.io//blog/a-big-map-to-intro-vue-next/"/>
    <id>https://jinjiang.github.io//blog/a-big-map-to-intro-vue-next/</id>
    <published>2016-05-12T00:47:39.000Z</published>
    <updated>2016-05-12T00:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是字最少的一篇了，都在图里 - -</p><p>文字介绍稍后抽空再补补</p><p><a href="http://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg" target="_blank" rel="noopener"><img src="http://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg" alt=""></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这可能是字最少的一篇了，都在图里 - -&lt;/p&gt;
&lt;p&gt;文字介绍稍后抽空再补补&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Code Review for Vue 2.0 Preview</title>
    <link href="https://jinjiang.github.io//blog/code-review-for-vue-next/"/>
    <id>https://jinjiang.github.io//blog/code-review-for-vue-next/</id>
    <published>2016-04-27T17:16:03.000Z</published>
    <updated>2016-05-10T18:17:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>是的！<a href="http://jiongks.name/blog/announcing-vue-2/" target="_blank" rel="noopener">Vue 2.0 发布了！</a> 源代码仓库<a href="https://github.com/vuejs/vue/tree/next" target="_blank" rel="noopener">在此</a></p><p>首先，当我第一次看到 Vue 2.0 的真面目的时候，我的内心是非常激动的</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>来个简单的 demo，首先把 <code>dist/vue.js</code> 导入到一个空白的网页里，然后写：</p><p><strong>当然，在大家阅读下面所有的内容之前，先想象一下，这是一个运行时 min+gzip 后只有 12kb 大小的库</strong></p><pre><code>&lt;script src=&quot;./dist/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;  Hello {{who}}&lt;/div&gt;&lt;script&gt;  new Vue({    el: &apos;#app&apos;,    data: {who: &apos;Vue&apos;}  })&lt;/script&gt;</code></pre><p>你将看到 “Hello Vue”</p><p>然后再看一个神奇的：</p><pre><code>&lt;script src=&quot;./dist/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  new Vue({    el: &apos;#app&apos;,    render: function () {      with (this) {        __h__(&apos;div&apos;,          {staticAttrs:{&quot;id&quot;:&quot;app&quot;}},          [(&quot;\n  Hello &quot;+__toString__(who)+&quot;\n&quot;)],          &apos;&apos;        )      }    }    data: {who: &apos;Vue&apos;}  })&lt;/script&gt;</code></pre><p>这个是 compile 过后的格式，大家会发现首先 <code>#app</code> 下不需要写模板了，然后 <code>&lt;script&gt;</code> 里多了一个 <code>render</code> 字段，Vue 在运行时其实是会把模板内容先转换成渲染方法存入 <code>render</code> 字段，然后再执行，如果发现 <code>render</code> 已经存在，就跳过模板解析过程直接渲染。所以在 Vue 2.0 中写一段模板和写一个 <code>render</code> option 是等价的。为什么要这样设计，稍后会我们会涉及到。</p><a id="more"></a><h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h3><p>废话不说，来看<a href="https://github.com/vuejs/vue/tree/next" target="_blank" rel="noopener">仓库</a></p><p>哎呀好东西太多我都不知道该先讲哪个啦！</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json - -"></a><code>package.json</code> - -</h3><p><a href="https://github.com/vuejs/vue/blob/next/package.json" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/next/package.json</a></p><p>先看这里，我个人习惯是拿到仓库之后除了 README (它没写) 就先看这个。和 1.x 相比，开发工具链还是以 rollup + webpack + karma 为主，开发的时候用 webpack 加 watch；打包的时候用 rollup 快速而且可以自动删掉没用到的代码片段；测试的时候用 karma 各种组合，包括 e2e、spec、coverage、sauce等。语法检查用了 eslint 这个似乎没什么争议和悬念。另外我发现了两个新东西：<a href="http://nightwatchjs.org/" target="_blank" rel="noopener">nightwatch</a> 和 <a href="https://www.npmjs.com/package/selenium-server" target="_blank" rel="noopener">selenium-server</a></p><p>另外你们就选眼睛再迟钝也会看到 ssr 这个词吧！对，就是服务端渲染 Server-Side Rendering！先不急，这个最后说，你们可以先去 high 一会儿</p><h3 id="src"><a href="#src" class="headerlink" title="src"></a><code>src</code></h3><p>作为一个见证了一小段 Vue 2.0 成长过程的脑残粉，我得跟大家从时间线的角度介绍一下这个文件夹：</p><h4 id="compiler-runtime"><a href="#compiler-runtime" class="headerlink" title="compiler + runtime"></a><code>compiler</code> + <code>runtime</code></h4><p>早些时候 Vue 2.0 的代码还是这样分的，一半运行时，一半(预)编译时，中间会通过一个 JavaScript 的格式严格划清界限，即源代码 template + JavaScript 经过编译之后变成了一段纯 JavaScript 代码，然后这段纯 JavaScript 的代码又可以在运行时被执行渲染。</p><p>这里面奇妙的地方是：编译时的代码完全可以脱离浏览器预执行，也可以在浏览器里执行。所以你可以把代码提前编译好，减轻运行时的负担。</p><p>由于 Vue 2.0 对 template 的解析没有借助 DOM 以及 fragment document，而是在 John Resig 的 <a href="https://github.com/vuejs/vue/blob/14feb83879fe32fc9c54eddf33c6c5ef2fb4e8a2/src/compiler/parser/html-parser.js" target="_blank" rel="noopener">HTML Parser</a> 基础上实现的，所以完全可以在任何主流的 JavaScript 环境中执行，这也为 ssr 提供了必要的基础</p><p>Vue 最早会打包生成三个文件，一个是 runtime only 的文件 vue.common.js，一个是 compiler only 的文件 compiler.js，一个是 runtime + compiler 的文件 vue.js，它们有三个打包入口，都放在了 <code>entries</code> 目录下，这是 <code>src</code> 里的第三个文件夹，第四个文件夹是 <code>shared</code>，放置一些运行时和编译时都会用到的工具方法集。</p><h4 id="compiler-runtime-platforms"><a href="#compiler-runtime-platforms" class="headerlink" title="compiler + runtime + platforms"></a><code>compiler</code> + <code>runtime</code> + <code>platforms</code></h4><p>Wahahaha~</p><p>这要说到 Vue 2.0 的第二个优点：virtual-DOM！virtual-DOM 有很多优点，也被很多人热议，而 Vue 2.0 里面的 virtual-DOM 简直是把它做到了极致！代码非常简练，而且性能超高 (据说秒杀 React，我自己没试过，大家可以自己比比看)。在这一点上编译器的前置起到了非常重要的作用，而且很多 diff 算法的优化点而且是在运行时之前就准备好的。</p><p>另外 virtual-DOM 的另一个优点当然就是可以对渲染引擎做一般化的抽象，进而适配到更多类型的终端渲染引擎上！所以在我的怂恿下，小右把本来在 <code>runtime</code> 下的 <code>runtime/dom</code> 文件夹挪到了一个名叫 <code>platforms</code> 的新文件夹下，改名叫 <code>platforms/web/runtime</code>，把本来 <code>compiler</code> 文件夹下 web 相关的 <code>modules</code> 挪到了 <code>platforms/web/compiler</code>！</p><p>(是的没错，今天在 <a href="http://alibaba.github.io/weex/" target="_blank" rel="noopener">Weex</a> 的子仓库里已经有另外一个 <code>platforms/weex</code> 文件夹了耶)</p><h4 id="compiler-runtime-platforms-server"><a href="#compiler-runtime-platforms-server" class="headerlink" title="compiler + runtime + platforms + server"></a><code>compiler</code> + <code>runtime</code> + <code>platforms</code> + <code>server</code></h4><p>是的没有错！Vue 2.0 既然已经有了 virtual-DOM，也有了运行环境无关的 compiler，为什么不能 ssr 呢？！Vue 2.0 不只是简单的把预渲染拿到服务端这么简单，Vue 2.0 ssr 除了提供传统的由源文件编译出字符串之外，还提供了输出 stream 的功能，这样服务端的渲染不会因为大量的同步字符串处理而变慢。即：<code>createRenderer()</code> 会返回 <code>renderToString()</code> 和 <code>renderToStream()</code> 两个方法。同时，在 <code>platforms/web</code> 文件夹下除了 <code>runtime</code> 和 <code>compiler</code> 之外又多了一个 <code>server</code> 目录，这样编译器、服务端流式预渲染、运行时的铁三角架构就这样达成了！</p><h3 id="test"><a href="#test" class="headerlink" title="test"></a><code>test</code></h3><p>说到测试，我惊奇的发现，在带来了这么多颠覆性的改变之后，Vue 2.0 竟然完好保留了绝大多数 1.0 的 API 设计，而且更快更小巧延展性更强。Vue 2.0 在前期研发阶段主要是通过粗线条的 e2e 测试进行质量保障的，因为版本延续性做得非常好，所以这部分在 1.x 的积累已经帮上很大忙了。现在 Vue 2.0 逐渐的在从 feature 的角度在进一步覆盖测试用例，对每个 API 和每个流程进行测试。目前以我个人的感觉主要的常见的链路都已经比较畅通了，具体功能细节上偶尔还是会遇到 bug 待修复，不过作为一个新兴的 Vue 2.0 来说，相信这已经远远超过大家的预期了！</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>我觉得 Vue 2.0 在编译器和运行时的解耦上做得超级棒！中间格式设计得也非常巧妙，把静态的部分在编译时就分析出来，而且通过非常简单的 <code>__h__</code>, <code>__renderList__</code> 等方法就搞定了几乎所有的逻辑控制和数据绑定。之前我个人在实践 Weex 的时候也是会把 template 提前 compile，但只是 compile 成一段 JSON，逻辑分析还是在运行时做的，当时和小右交流的时候就在讨论，能不能把分析过程也前置，无奈自己功力不够啊，一直没搞出来。看到 2.0 横空出世，简直是泪流满面有木有！！</p><p>还有一件事情也是之前跟小右聊到过，就是目前 Vue 提供的很多 directive 包括 filter 也都是有机会前置处理的，所以在 Vue 2.0 里，有相当一部分 directive 是前置处理成一般格式的，运行时只是针对各端的渲染机制保留了 attr, style, class, event 等几个最基础简单的解析过程，比如 if, for, else 都直接在 compile 的时候被解开了。而且 Vue 2.0 把这部分内容抽象得如此清晰，除了赞叹还是赞叹！！</p><p>还有就是，你们去看看 Vue 2.0 的提交记录，300+ 次提交，上万行高效优质的代码，总共花了差不多两周的时间，而且提交时间几乎遍布二十四个小时……</p><p>别的不多啰嗦了，我觉得大家还是亲自看过 Vue 2.0 的源码，会对这些内容有更深刻的了解。从今天起，fork + clone Vue 2.0，写写 demo、写写测试、练练英文 XD go!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的！&lt;a href=&quot;http://jiongks.name/blog/announcing-vue-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue 2.0 发布了！&lt;/a&gt; 源代码仓库&lt;a href=&quot;https://github.com/vuejs/vue/tree/next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在此&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，当我第一次看到 Vue 2.0 的真面目的时候，我的内心是非常激动的&lt;/p&gt;
&lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;来个简单的 demo，首先把 &lt;code&gt;dist/vue.js&lt;/code&gt; 导入到一个空白的网页里，然后写：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然，在大家阅读下面所有的内容之前，先想象一下，这是一个运行时 min+gzip 后只有 12kb 大小的库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;./dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
  Hello {{who}}
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
  new Vue({
    el: &amp;apos;#app&amp;apos;,
    data: {who: &amp;apos;Vue&amp;apos;}
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你将看到 “Hello Vue”&lt;/p&gt;
&lt;p&gt;然后再看一个神奇的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;./dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
  new Vue({
    el: &amp;apos;#app&amp;apos;,
    render: function () {
      with (this) {
        __h__(&amp;apos;div&amp;apos;,
          {staticAttrs:{&amp;quot;id&amp;quot;:&amp;quot;app&amp;quot;}},
          [(&amp;quot;\n  Hello &amp;quot;+__toString__(who)+&amp;quot;\n&amp;quot;)],
          &amp;apos;&amp;apos;
        )
      }
    }
    data: {who: &amp;apos;Vue&amp;apos;}
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个是 compile 过后的格式，大家会发现首先 &lt;code&gt;#app&lt;/code&gt; 下不需要写模板了，然后 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 里多了一个 &lt;code&gt;render&lt;/code&gt; 字段，Vue 在运行时其实是会把模板内容先转换成渲染方法存入 &lt;code&gt;render&lt;/code&gt; 字段，然后再执行，如果发现 &lt;code&gt;render&lt;/code&gt; 已经存在，就跳过模板解析过程直接渲染。所以在 Vue 2.0 中写一段模板和写一个 &lt;code&gt;render&lt;/code&gt; option 是等价的。为什么要这样设计，稍后会我们会涉及到。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue 2.0 发布啦！</title>
    <link href="https://jinjiang.github.io//blog/announcing-vue-2/"/>
    <id>https://jinjiang.github.io//blog/announcing-vue-2/</id>
    <published>2016-04-27T00:19:02.000Z</published>
    <updated>2017-07-31T19:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.cyoou0ivk" target="_blank" rel="noopener">https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.cyoou0ivk</a></p><p><img src="http://ww1.sinaimg.cn/mw1024/660d0cdfgw1f3bs1115fsj20ug0jiq6m.jpg" alt=""></p><p>今天我们非常激动的首发 Vue 2.0 preview 版本，这个版本带来了很多激动人心的改进和新特性。我们来看看这里面都有些什么！</p><a id="more"></a><h3 id="更轻，更快"><a href="#更轻，更快" class="headerlink" title="更轻，更快"></a>更轻，更快</h3><p>Vue.js 始终聚焦在轻量和快速上面，而 2.0 把它做得更好。现在的渲染层基于一个轻量级的 virtual-DOM 实现，在大多数场景下初试化渲染速度和内存消耗都提升了 2~4 倍 (详见这里的 <a href="https://github.com/vuejs/vue/tree/next/benchmarks" target="_blank" rel="noopener">benchmarks</a>)。从模板到 virtuel-DOM 的编译器和运行时是可以独立开来的，所以你可以将模板预编译并只通过 Vue 的运行时让你的应用工作起来，而这份运行时的代码 min+gzip 之后只有不到 12kb (提一下，React 15 在 min+gzip 之后的大小是 44kb)。编译器同样可以在浏览器中工作，也就是说你也可以写一段 script 标签然后开始你的工作，就像以前一样。而即便你把编译器加进去，build 出来的文件 min+gzip 之后也仅有 17kb，仍然小于目前的 1.0 版本。</p><h3 id="不是普通的-Virtual-DOM"><a href="#不是普通的-Virtual-DOM" class="headerlink" title="不是普通的 Virtual-DOM"></a>不是普通的 Virtual-DOM</h3><p>现在 virtual-DOM 有点让人听腻了，因为社区里有太多种实现，但是 Vue 2.0 的实现有与众不同的地方。和 Vue 的响应式系统结合在一起之后，它可以让你不必做任何事就获得完全优化的重渲染。由于每个组件都会在渲染时追踪其响应依赖，所以系统精确地知道应该何时重渲染、应该重渲染哪些组件。不需要 <code>shouldComponentUpdate</code>，也不需要 immutable 数据 - <strong>it just works</strong>.</p><p>除此之外，Vue 2.0 从模板到 virtuel-DOM 的编译阶段使用了一些高阶优化：</p><ol><li><p>它会检测出静态的 class 名和 attributes 这样它们在初始化渲染之后就永远都不会再被比对。</p></li><li><p>它会检测出最大静态子树 (就是不需要动态性的子树) 并且从渲染函数中萃取出来。这样在每次重渲染的时候，它就会直接重用完全相同的 virtual nodes 同时跳过比对。</p></li></ol><p>这些高阶优化通常只会在使用 JSX 时通过 Babel plugin 来做，但是 Vue 2.0 即使在使用浏览器内的编译器时也能做到。</p><p>新的渲染系统同时允许你通过简单的冻结数据来禁用响应式转换，配以手动的强制更新，这意味着你对于重渲染的流程实际上有着完全的控制权。</p><p>以上这些技术组合在一起，确保了 Vue 2.0 在每一个场景下都能够拥有高性能的表现，同时把开发者的负担和成本降到了最低。</p><h3 id="Templates-JSX-or-Hyperscript"><a href="#Templates-JSX-or-Hyperscript" class="headerlink" title="Templates, JSX, or Hyperscript?"></a>Templates, JSX, or Hyperscript?</h3><p>开发者对于用模板还是 JSX 有很多的争执。一方面，模板更接近 HTML - 它能更好地反映你的 app 的语义结构，并且易于思考视觉上的设计、布局和样式。另一方面，模板作为一个 DSL 也有它的局限性 - 相比之下 JSX/hyperscript 的程序本质使得它们具有图灵完备的表达能力。</p><p>作为一个兼顾设计和开发的人，我喜欢用模板来写大部分的界面，但在某些情况下我也希望能拥有 JSX/hyperscript 的灵活性。举例来说，当你想在一个组件中程序化的处理其子元素时，基于模板的 slot 机制会显得比较有局限性。</p><p>那么，为什么不能同时拥有它们呢？在 Vue 2.0 中，你可以继续使用熟悉的模板语法，但当你觉得受限制的时候，你也可以直接写底层的 virtual-DOM 代码，只需用一个 <code>render</code> 函数替换掉 <code>template</code> 选项。你甚至可以直接在你的模板里使用一个特殊的 <code>&lt;render&gt;</code> 标签来嵌入渲染函数！一个框架，两全其美。</p><h3 id="流式服务端渲染"><a href="#流式服务端渲染" class="headerlink" title="流式服务端渲染"></a>流式服务端渲染</h3><p>既然迁移到了 virtual-DOM，Vue 2.0 自然支持服务端渲染和客户端的 hydration（直接使用服务端渲染的 DOM 元素）。当前服务端渲染的实现有一个痛点，比如在 React 里，渲染是同步的，所以如果这个 app 比较复杂的话它会阻塞服务器的 event loop。同步的服务端渲染在优化不当的情况下甚至会对客户端获得内容的速度带来负面影响。Vue 2.0 提供了内建的流式服务端渲染 - 在渲染组件时返回一个可读的 stream，然后直接 pipe 到 HTTP response。流式渲染能够确保服务端的响应度，也能让用户更快地获得渲染内容。</p><h3 id="解锁更多可能性"><a href="#解锁更多可能性" class="headerlink" title="解锁更多可能性"></a>解锁更多可能性</h3><p>基于新的架构，我们还有更多的可能性有待开发 - 比如在手机端渲染到 native 界面。目前我们正在探索一个 Vue.js 2.0 的端，它会用 <a href="http://alibaba.github.io/weex/" target="_blank" rel="noopener">weex</a>：一个由中国最大科技公司之一的阿里巴巴的工程师们维护的项目，作为一个 native 的渲染层。同时从技术角度 Vue 2.0 运行在 ReactNative 上也是可行的。让我们拭目以待！</p><h3 id="兼容性以及接下来的计划"><a href="#兼容性以及接下来的计划" class="headerlink" title="兼容性以及接下来的计划"></a>兼容性以及接下来的计划</h3><p>Vue.js 2.0 仍然处在 pre-alpha 阶段，但是你可以来<a href="https://github.com/vuejs/vue/tree/next/" target="_blank" rel="noopener">这里</a> 查看源代码。尽管 2.0 是一个完全重写的项目，但是除了一些有意废弃掉的功能，API 和 1.0 是大部分兼容的。看看 <a href="https://github.com/vuejs/vue/tree/next/examples" target="_blank" rel="noopener">2.0 中一模一样的官方例子</a> - 你会发现几乎没有什么变化！</p><p>对于部分功能的废弃，本质上是为了提供更简洁的 API 从而提高开发者的效率。你可以移步<a href="https://github.com/vuejs/vue/wiki/2.0-features" target="_blank" rel="noopener">这里</a> 查看 1.0 和 2.0 的特性比对。如果你在现有的项目中大量地使用着一些被废弃的特性，这意味着会有一定的迁移成本，不过我们在未来会提供更详实的升级指导。</p><p>现在我们还有很多工作没有完成。一旦我们达到了令人满意的测试覆盖率，我们将会推出 alpha 版本，同时我们希望能在五月底六月初推出 beta 版。除了更多的测试之外，我们也需要更新相关库（如 vue-router, Vuex, vue-loader, vueify…）的支持。目前只有 Vuex 在 2.0 下可以直接使用，但是我们会确保在 2.0 正式发布时所有东西都会顺畅地工作。</p><p>我们不会因此而忘记 1.x 哦！1.1 将会和 2.0 beta 独立发布，提供六个月 critical bug fixes 和九个月安全升级的长效服务 (LTS)。同时 1.1 还会包含可选的废弃特性警告，让你为升级到 2.0 做好充足的准备。尽请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.cyoou0ivk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.cyoou0ivk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/660d0cdfgw1f3bs1115fsj20ug0jiq6m.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天我们非常激动的首发 Vue 2.0 preview 版本，这个版本带来了很多激动人心的改进和新特性。我们来看看这里面都有些什么！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>务实的小而美</title>
    <link href="https://jinjiang.github.io//blog/small-and-beautiful/"/>
    <id>https://jinjiang.github.io//blog/small-and-beautiful/</id>
    <published>2016-01-05T17:48:32.000Z</published>
    <updated>2016-01-06T01:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>随意分享几则自己近期的感悟</p><h3 id="人不够？"><a href="#人不够？" class="headerlink" title="人不够？"></a>人不够？</h3><p>我自己发现周围的同学越来越把一句话挂在嘴边，那就是：我们就这么些人，想搞定这件事情是远远不够的</p><p>说白了，大家觉得“人多好办事”，“规模”这个词很多情况下几乎就是个褒义词。</p><p>但是今天有些变化正在悄然发生，比如人类的学习能力越来越强，同时信息技术越来越发达，学习新知识的门槛越来越低，比如各技术领域的成熟度越来越高，比如移动时代前所未有的技术挑战，在有限的硬件性能和网络带宽的情况下，越是“规模”的东西越难以维持；比如体力和知识都逐渐远离核心竞争优势等等</p><h3 id="拥抱社区，“我们有更多人”"><a href="#拥抱社区，“我们有更多人”" class="headerlink" title="拥抱社区，“我们有更多人”"></a>拥抱社区，“我们有更多人”</h3><p>一件事搞得起来搞不起来，逐渐不取决于我们的团队有多少人，而取决于我们有没有让这件事情发生在最广阔的舞台上，因为一个技术团队再多人，哪怕一百多人，相比起任何一个知名技术社区都是九牛一毛，而一个集团、一个国家、一门语言的社区，相比起全球的互联网社区，也都是渺小的。所以今天，我们想在技术上成就一件事，未必需要很大的团队，未必需要很多人在身边</p><p>同时，我们也不能小看个体在科技发展中所起到的关键作用。技术的不断融合和碰撞也加速了这件事情。所以更重要的不是团队有多少人，而是团队有没有能够真正起到关键作用的个体，找到对的人，比组建一支上百人的团队要重要得多</p><h3 id="从社区汲取最好的技术"><a href="#从社区汲取最好的技术" class="headerlink" title="从社区汲取最好的技术"></a>从社区汲取最好的技术</h3><p>我敢说，抛开具有真正技术驱动力的公司，绝大多数公司的技术工作都能够在社区找到现成并且适合的方案，也都不太需要最高精简的科研探索。一个务实的技术方案，一定是在大量的社区成熟技术基础上建立起来的，再加上一点点针对自身业务独特性的技术实践。不过看上去“没什么自己的东西”罢了，如果大家很介意这东西“得是我自己的”，那么你需要继续考虑这个问题：自己搞出来的东西能不能比今天社区的更好，能不能发展成更好的社区，是否可以在社区中的深度参与从而把“别人的”变成“自己的”</p><h3 id="在社区中施展-检验自己的技术"><a href="#在社区中施展-检验自己的技术" class="headerlink" title="在社区中施展+检验自己的技术"></a>在社区中施展+检验自己的技术</h3><p>然而社区不应该只有索取，还应该有奉献，如果你发现有件事情是别人也会再次遇到的那种事情，但社区没有合适现成的东西，那么恭喜你，赶紧开工吧</p><p>有的时候觉得社区化的技术发展也有它残酷的一面，同类的方案或工具库基本上也就全球数一数二的几个能生存下来，并且体现出可观的价值，稍微差一点的，也许绝对实力没有差很多，但只要不是第一，所产生的价值和影响力就少得可怜了。所以想掂量掂量自己，看看是不是这块料，不妨放到社区里跟大家一起来一场真正的PK吧！也别自己憋着，别觉得“等我弄得再完善一点再给你们看”，因为在社区化的技术发展中，这样做只会让自己越来越没有价值和勇气把它拿出来了。当然也不必贪多，哪怕是一个小小的功能，如果做到最好，能够被全球的开发者使用，那也是极好的</p><h3 id="合理的把技术运用在工作中"><a href="#合理的把技术运用在工作中" class="headerlink" title="合理的把技术运用在工作中"></a>合理的把技术运用在工作中</h3><p>我们在工作中逐渐对人的评价，会由评价其绝对的技术实力，转向评价其运用各方面技术解决实际问题的能力。这两者之间有一个比较形象的比喻，就好比我们学生时期背单词，拿出任何一个单词来，都能立刻说出它的含义、发音、常用短语、同义词、反义词、各种形态，但面对具体的对话场景不知道该用哪个词最合适最得体，这是比较典型的一种现象。其实前者就像是一个人的技术实力，后者就像是一个人的解决实际问题的能力。所以新知识新技术不光要学，还要学以致用，如何合理运用技术解决实际问题才是我们真正希望看到的。</p><h3 id="把工作中的必经之路和常见任务萃取出来沉淀为最佳实践"><a href="#把工作中的必经之路和常见任务萃取出来沉淀为最佳实践" class="headerlink" title="把工作中的必经之路和常见任务萃取出来沉淀为最佳实践"></a>把工作中的必经之路和常见任务萃取出来沉淀为最佳实践</h3><p>现在回到“小而美的务实方案”这件事情上。我们认为看上去很重要、工作量很大、需要很多人来做的工作，是可以充分拥抱社区，汲取最好的技术，同时发挥关键角色的关键作用，并把技术合理运用在实际需求上。整件事情的成败有很多因素，但是“规模”这个因素显然不在考前的位置了</p><p>基于这样的思考，我觉得，自己喜欢的团队，是一个小而美的团队</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随意分享几则自己近期的感悟&lt;/p&gt;
&lt;h3 id=&quot;人不够？&quot;&gt;&lt;a href=&quot;#人不够？&quot; class=&quot;headerlink&quot; title=&quot;人不够？&quot;&gt;&lt;/a&gt;人不够？&lt;/h3&gt;&lt;p&gt;我自己发现周围的同学越来越把一句话挂在嘴边，那就是：我们就这么些人，想搞定这件事情
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue.js 1.0.0 发布了！</title>
    <link href="https://jinjiang.github.io//blog/vuejs-1-0-0-release/"/>
    <id>https://jinjiang.github.io//blog/vuejs-1-0-0-release/</id>
    <published>2015-10-28T23:36:44.000Z</published>
    <updated>2017-07-31T19:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为“打入敌人内部”的第一件事，转载一下 Vue.js 1.0.0 新世纪福音战士 (其实发这篇文章的时候已经 1.0.3 了) 正式发布的<a href="http://vuejs.org/2015/10/26/1.0.0-release/" target="_blank" rel="noopener">博文</a> ^_^</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/10/2139857295.png" alt="Vue.js"></p><hr><blockquote><p>Hi HN (Hacker News)! 如果你还不熟悉 Vue.js 的话，可以通过<a href="http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/" target="_blank" rel="noopener">这篇文章 (英文)</a>对其有个总体印象。</p></blockquote><p>在经历了 300+ 次提交、8 次 alpha、4 次 beta 和 2 次 rc 之后，今天我很荣幸的向大家宣布 <a href="https://github.com/vuejs/vue/releases/tag/1.0.0" target="_blank" rel="noopener">Vue.js 1.0.0 Evangelion</a> 正式发布了！非常感谢所有参与 API 重设计的同学们——没有来自社区的贡献这是不可能完成的。</p><a id="more"></a><h3 id="模板语法改进"><a href="#模板语法改进" class="headerlink" title="模板语法改进"></a>模板语法改进</h3><p>1.0 的模板语法解决了很多微小的一致性问题，并使得 Vue 的模板更加简洁且易于阅读。最值得留意的新特性就是 <code>v-on</code> 和 <code>v-bind</code> 的语法简写：</p><pre><code>&lt;!-- 简写版 v-bind:href --&gt;&lt;a :href=&quot;someURL&quot;&gt;&lt;/a&gt;&lt;!-- 简写版 v-on:click --&gt;&lt;button @click=&quot;onClick&quot;&gt;&lt;/button&gt;</code></pre><p>当使用一个子组件的时候，<code>v-on</code> 用来监听自定义事件，<code>v-bind</code> 用来绑定属性 (props)。这些简写让子组件变得更易用：</p><pre><code>&lt;item-list  :items=&quot;items&quot;  @ready=&quot;onItemsReady&quot;  @update=&quot;onItemsUpdate&quot;&gt;&lt;/item-list&gt;</code></pre><h3 id="API-清理"><a href="#API-清理" class="headerlink" title="API 清理"></a>API 清理</h3><p>Vue.js 1.0 的总体目标是使其适用于更大型的项目。这也是很多 API 被弃用的原因。在被弃用的 API 中，除了很少被用及之外，最常见的理由就是它会导致可维护性被破坏。特别是，我们弃用了难以维护的功能，并把组件提炼隔离开，使其不会对项目其它部分产生影响。</p><p>比如，在 0.12 中默认资源 (asset) 方案会隐性降级到组件树中的父级。这使得组件中的可用资源非常不确定，并且取决于在运行时的用法。在 1.0 中，所有的资源都基于严格模式进行解析，也没有了隐性降级。<code>inherit</code> 选项也被移除了，因为它很容易导致组件强耦合，无法提炼。</p><h3 id="更快的初始化渲染"><a href="#更快的初始化渲染" class="headerlink" title="更快的初始化渲染"></a>更快的初始化渲染</h3><p>1.0 用 <code>v-for</code> 指令 (directive) 取代了 <code>v-repeat</code>。除了提供相同的功能和更直观的作用域之外，<code>v-for</code> 将初始化渲染大列表和大表格时的性能提升了 <strong>100%</strong>！</p><h3 id="更强大的工具"><a href="#更强大的工具" class="headerlink" title="更强大的工具"></a>更强大的工具</h3><p>在 Vue.js core 之外，还有很多令人激动的东西：<a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">vue-loader</a> 和 <a href="https://github.com/vuejs/vueify" target="_blank" rel="noopener">vueify</a> 的新升级，包括：</p><ul><li><p>组件热加载。当一个 <code>*.vue</code> 组件被编辑之后，其所有活跃实例都可以在页面不刷新的情况下完成热转换。这意味着你不需要重新加载 app 就可以完成诸如样式或模板的小调整；而 app 本身及其被转换的组件的状态可以被保留，这大大提升了开发体验。</p></li><li><p>局部 CSS。通过在你的 <code>*.vue</code> 组件的 style 标签上简单加入一个 <code>scoped</code> 特性，该组件的模板和最终生成的 CSS 就会被奇妙的重写以保证组件的样式只被应用在其自身的元素上。最重要的是，父组件的特殊样式<strong>不会</strong>泄露到嵌套的子组件当中。</p></li><li><p>默认支持 ES2015。JavaScript 一直在进化。你可以用最新的语法写出更简洁生动的代码。<code>vue-loader</code> 和 <code>vueify</code> 现在会直接转换你的 <code>*.vue</code> 组件中的 JavaScript，无需额外的设置。今天，就来写未来的 JavaScript 吧！</p></li></ul><p>结合 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">vue-router</a>，Vue.js 现在不只是一个库了——它提供了一个构建复杂单页应用的稳固基础。</p><h3 id="下一步？"><a href="#下一步？" class="headerlink" title="下一步？"></a>下一步？</h3><p>如一般 1.0.0 所提倡的，核心 API 将会保持稳定服务于可预见的未来，库也做好了产品级别的准备。未来的开发会专注于：</p><ol><li><p>改善 <code>vue-loader</code> 并使其做好产品级别的准备。</p></li><li><p>捋顺开发体验，比如更好的开发者工具和 Vue.js 项目/组件脚手架的 CLI。</p></li><li><p>提供更多诸如教程和示例的学习资料。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“打入敌人内部”的第一件事，转载一下 Vue.js 1.0.0 新世纪福音战士 (其实发这篇文章的时候已经 1.0.3 了) 正式发布的&lt;a href=&quot;http://vuejs.org/2015/10/26/1.0.0-release/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博文&lt;/a&gt; ^_^&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/10/2139857295.png&quot; alt=&quot;Vue.js&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Hi HN (Hacker News)! 如果你还不熟悉 Vue.js 的话，可以通过&lt;a href=&quot;http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章 (英文)&lt;/a&gt;对其有个总体印象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在经历了 300+ 次提交、8 次 alpha、4 次 beta 和 2 次 rc 之后，今天我很荣幸的向大家宣布 &lt;a href=&quot;https://github.com/vuejs/vue/releases/tag/1.0.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue.js 1.0.0 Evangelion&lt;/a&gt; 正式发布了！非常感谢所有参与 API 重设计的同学们——没有来自社区的贡献这是不可能完成的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何成为一名卓越的前端工程师</title>
    <link href="https://jinjiang.github.io//blog/how-to-become-a-great-front-end-engineer/"/>
    <id>https://jinjiang.github.io//blog/how-to-become-a-great-front-end-engineer/</id>
    <published>2015-08-09T23:00:58.000Z</published>
    <updated>2017-06-26T20:39:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>译自 <a href="http://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/" target="_blank" rel="noopener">Philip Walton 的博客</a></p><p>看过之后非常有感触，很多观点都是自己长期非常坚持和认同的，所以翻译出来分享给更多的前端同学！</p><hr><p>最近我收到一封读者来信让我陷入了思考，信是这么写的：</p><blockquote><p>Hi Philip，您是否介意我问您是如何成为一名卓越 (great) 的前端工程师的？对此您有什么建议吗？</p></blockquote><p>我不得不承认，我很惊讶被问这样的问题，因为我从来不觉得自己是个很卓越的前端工程师。甚至我入行头几年时并不认为自己可以做好这一行。我只确定自己比自己想象中还才疏学浅，而且大家面试我的时候都不知道从何问起</p><p>话虽这么说，我到现在做得还算不错，而且成为了团队中有价值的一员。但我最终离开 (去寻求新的挑战——即我还不能够胜任的工作) 的时候，我经常会被要求招聘我的继任者。现在回看这些面试，我不禁感叹当我刚开始的时候自己在这方面的知识是多么的匮乏。我现在或许不会按照我自己的模型进行招聘，即便我个人的这种经历也有可能成功。</p><p>我在 web 领域工作越长时间，我就越意识到区分人才和顶尖人才的并不是他们的知识——而是他们思考问题的方式。很显然，知识在很多情况下是非常重要而且关键的——但是在一个快速发展的领域，你前进和获取知识的方式 (至少在相当长的一段时间里) 会比你已经掌握的知识显得更加重要。更重要的是：你是如何运用这些知识解决每天的问题的。</p><p>这里有许许多多的文章谈论你工作中需要的语言、框架、工具等等。我希望给一些不一样的建议。在这篇文章里，我想谈一谈一个前端工程师的心态，希望可以帮助大家找到通往卓越的道路。</p><a id="more"></a><h3 id="别光解决问题，想想究竟发生了什么"><a href="#别光解决问题，想想究竟发生了什么" class="headerlink" title="别光解决问题，想想究竟发生了什么"></a>别光解决问题，想想究竟发生了什么</h3><p>很多人埋头写 CSS 和 JavaScript 直到程序工作起来了，然后就去做别的事情了。我通过 code review 发现这种事经常发生。</p><p>我总会问大家：“为什么你会在这里添加 <code>float: left</code>？”或者“这里的 <code>overflow: hidden</code> 是必要的吗？”，他们往往答道：“我也不知道，可是我一删掉它们，页面就乱套了。”</p><p>JavaScript 也是一样，我总会在一个条件竞争的地方看到一个 <code>setTimeout</code>，或者有些人无意中阻止了事件传播，却不知道它会<a href="http://css-tricks.com/dangers-stopping-event-propagation/" target="_blank" rel="noopener">影响</a>到页面中其它的事件处理。</p><p>我发现很多情况下，当你遇到问题的时候，你只是解决当下的问题罢了。但是如果你永远不花时间理解问题的本源，你将一次又一次的面对相同的问题。</p><p>花一些时间找出为什么，这看上去费时费力，但是我保证它会节省你未来的时间。在完全理解整个系统之后，你就不需要总去猜测和论证了。</p><h3 id="学会预见未来的浏览器发展趋势"><a href="#学会预见未来的浏览器发展趋势" class="headerlink" title="学会预见未来的浏览器发展趋势"></a>学会预见未来的浏览器发展趋势</h3><p>前后端开发的一个主要区别在于后端代码通常都运行在完全由你掌控的环境下。前端相对来说不那么在你的掌控之中。不同用户的平台或设备是前端永恒的话题，你的代码需要优雅掌控这一切。</p><p>我记得自己 2011 年之前曾经阅读某主流 JavaScript 框架的时候看到过下面这样的代码 (简化过的)：</p><pre><code>var isIE6 = !isIE7 &amp;&amp; !isIE8 &amp;&amp; !isIE9;</code></pre><p>在这个例子中变量 IE6 为了判断 IE 浏览器版本是否是 6 或更低的版本。那么在 IE10 发布时，我们的程序判断还是会出问题。</p><p>我理解在真实世界特性检测并不 100% 工作，而且有的时候你不得不依赖有 bug 的特性或根据浏览器特性检测的错误设计白名单。但你为此做的每一件事都非常关键，因为你预见到了不再有 bug 的未来。</p><p>对于我们当中的很多人来说，我们今天写的代码都会比我们的工作周期要长。有些我写的代码已经过去 8 年多了还在产品线上运行。这让人很满足又很不安。</p><h3 id="阅读规范文档"><a href="#阅读规范文档" class="headerlink" title="阅读规范文档"></a>阅读规范文档</h3><p>浏览器有 bug 是很难免的事，但是当同一份代码在两个浏览器渲染出来的效果不一样，人们总会不假思索的推测，那个“广受好评”的浏览器是对的，而“不起眼”的浏览器是错的。但事实并不一定如此，当你的假设出现错误时，你选取的变通办法都会在未来遭遇问题。</p><p>一个就近的例子是 flex 元素的默认最小尺寸问题。根据<a href="http://www.w3.org/TR/css-flexbox/#min-size-auto" target="_blank" rel="noopener">规范</a>的描述，flex 元素初始化的 <code>min-width</code> 和 <code>min-height</code> 的值是 <code>auto</code> (而不是 0)，也就是说它们默认应该收缩到自己内容的最小尺寸。但是在过去长达 8 个月的时间里，只有 Firefox 的实现是准确的。[1]</p><p>如果你遇到了这个浏览器兼容性的问题并且发现 Chrome、IE、Opera、Safari 的效果相同而 Firefox 和它们不同时，你很可能会认为是 Firefox 搞错了。事实上这种情况我见多了。很多我在自己 <a href="https://github.com/philipwalton/flexbugs" target="_blank" rel="noopener">Flexbugs</a> 项目上报的问题都是这样的。而且这些解决方案的问题会在两周之后 Chrome 44 修复之后被体现出来。和遵循标准的解决方案相比，这些方案都伤害到了正确的规范行为。[2]</p><p>当同一份代码在两个或更多浏览器的渲染结果不同时，你应该花些时间确定哪个效果是正确的，并且以此为标准写代码。你的解决方案应该是对未来友好的。</p><p>额外的，所谓“卓越”的前端工程师是时刻感受变化，在某项技术成为主流之前就去适应它的，甚至在为这样的技术做着贡献。如果你锻炼自己看到规范就能在浏览器支持它之前想象出它如何工作的，那么你将成为谈论并影响其规范开发的那群人。</p><h3 id="阅读别人的代码"><a href="#阅读别人的代码" class="headerlink" title="阅读别人的代码"></a>阅读别人的代码</h3><p>出于乐趣阅读别人的代码可能并不是你每周六晚上会想到的娱乐项目，但是这毫无疑问是你成为优秀工程师的最佳途径。</p><p>自己独立解决问题绝对是个不错的方式，但是这不应该是你唯一的方式，因为它很快就会让你稳定在某个层次。阅读别人的代码会让你开阔思维，并且阅读和理解别人写的代码也是团队协作或开源贡献必须具备的能力。</p><p>我着实认为很多公司在招聘新员工的时候犯的最大错误是他们只评估应聘者从轮廓开始写新代码的能力。我几乎没有见过一场面试会要求应聘者阅读现有的代码，找出其中的问题，并修复它们。缺少这样的面试流程真的非常不好，因为你作为工程师的很多时间都花费在了在现有的代码的基础上增加或改变上面，而不是搭建新的东西。</p><h3 id="与比你聪明的人一起工作"><a href="#与比你聪明的人一起工作" class="headerlink" title="与比你聪明的人一起工作"></a>与比你聪明的人一起工作</h3><p>我印象中的很多前端开发者 (相比于全职工作来说) 都是自由职业者，有同类想法的后端开发者并没有那么多。可能是因为很多前端都是自学成才的而后端则多是学校里学出来的。</p><p>不论是自我学习还是自我工作，我们都面对一个问题：你并没有机会从比你聪明的家伙那里学到什么。没有人帮你 review 代码，也没有人与你碰撞灵感。</p><p>我强烈建议，最起码在你职业发展的前期，你要在一个团队里工作，尤其是一个普遍比你聪明而且有经验的团队里工作。</p><p>如果你最终会在你职业发展的某个阶段选择独立工作，一定要让自己投身在开源社区当中。保持对开源项目的活跃贡献，这会给你团队工作相同甚至更多的益处。</p><h3 id="“造轮子”"><a href="#“造轮子”" class="headerlink" title="“造轮子”"></a>“造轮子”</h3><p>造轮子在商业上是非常糟糕的，但是从学习的角度是非常好的。你可能很想把那些库和小工具直接从 npm 里拿下来用，但也可以想象一下你独立建造它们能够学到多少东西。</p><p>我知道有些人读到这里是特别不赞成的。别误会，我并没有说你不应该使用第三方代码。那些经过充分测试的库具有多年的测试用例积累和已知问题积累，使用它们绝对是非常明智的选择。</p><p>但在这里我想说的是如何从优秀到卓越。我觉得这个领域很多卓越的人都是我每天在用的非常流行的库的作者或维护者。</p><p>你可能不曾打造过自己的 JavaScript 库也拥有一个成功的职业发展，但是你从不把自己手弄脏是几乎不可能淘到金子的。</p><p>在这一行大家普遍会问的一个问题是：我接下来应该做点什么？如果你没有试着学一个新的工具创建一个新的应用，那不妨试着重新造一个你喜欢的 JavaScript 库或 CSS 框架。这样做的一个好消息是，在你遇到困难的时候，所有现成的库的源代码都会为你提供帮助。</p><h3 id="把你学到的东西都记录下来"><a href="#把你学到的东西都记录下来" class="headerlink" title="把你学到的东西都记录下来"></a>把你学到的东西都记录下来</h3><p>最后，但丝毫不逊色的是，你应该把你学到的东西记录下来。这样做有很多原因，但也许最重要的原因是它强迫你更好的理解这件事。如果你无法讲清楚它的工作原理，在整个过程中它会推动你自己把并不真正理解的东西弄清楚。很多情况下你根本意识不到自己还不理解它们——直到自己动手写的时候。</p><p>根据我的经验，写作、演讲、做 demo 是强迫自己完全深入理解一件事的最佳方式。就算你写的东西没有人看，整个过程也会让你受益匪浅。</p><h4 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes:"></a>Footnotes:</h4><ol><li>Firefox implemented the spec change in <a href="https://en.wikipedia.org/wiki/Firefox_release_history" target="_blank" rel="noopener">version 34</a> on December 1, 2014. Chrome implemented it in <a href="https://en.wikipedia.org/wiki/Google_Chrome_release_history" target="_blank" rel="noopener">version 44</a> on July 21, 2015, which means Opera will get it shortly. Edge shipped with this implemented on July 29, 2015. A Safari implementation appears to be <a href="https://bugs.webkit.org/show_bug.cgi?id=136754" target="_blank" rel="noopener">in progress</a>.</li><li>You can refer to <a href="https://github.com/philipwalton/flexbugs#1-minimum-content-sizing-of-flex-items-not-honored" target="_blank" rel="noopener">Flexbug #1</a> for a future-friendly, cross-browser workaround to this issue.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译自 &lt;a href=&quot;http://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Philip Walton 的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看过之后非常有感触，很多观点都是自己长期非常坚持和认同的，所以翻译出来分享给更多的前端同学！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近我收到一封读者来信让我陷入了思考，信是这么写的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hi Philip，您是否介意我问您是如何成为一名卓越 (great) 的前端工程师的？对此您有什么建议吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我不得不承认，我很惊讶被问这样的问题，因为我从来不觉得自己是个很卓越的前端工程师。甚至我入行头几年时并不认为自己可以做好这一行。我只确定自己比自己想象中还才疏学浅，而且大家面试我的时候都不知道从何问起&lt;/p&gt;
&lt;p&gt;话虽这么说，我到现在做得还算不错，而且成为了团队中有价值的一员。但我最终离开 (去寻求新的挑战——即我还不能够胜任的工作) 的时候，我经常会被要求招聘我的继任者。现在回看这些面试，我不禁感叹当我刚开始的时候自己在这方面的知识是多么的匮乏。我现在或许不会按照我自己的模型进行招聘，即便我个人的这种经历也有可能成功。&lt;/p&gt;
&lt;p&gt;我在 web 领域工作越长时间，我就越意识到区分人才和顶尖人才的并不是他们的知识——而是他们思考问题的方式。很显然，知识在很多情况下是非常重要而且关键的——但是在一个快速发展的领域，你前进和获取知识的方式 (至少在相当长的一段时间里) 会比你已经掌握的知识显得更加重要。更重要的是：你是如何运用这些知识解决每天的问题的。&lt;/p&gt;
&lt;p&gt;这里有许许多多的文章谈论你工作中需要的语言、框架、工具等等。我希望给一些不一样的建议。在这篇文章里，我想谈一谈一个前端工程师的心态，希望可以帮助大家找到通往卓越的道路。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手机淘宝前端的图片相关工作流程梳理</title>
    <link href="https://jinjiang.github.io//blog/our-image-workflow/"/>
    <id>https://jinjiang.github.io//blog/our-image-workflow/</id>
    <published>2015-08-09T20:15:46.000Z</published>
    <updated>2015-08-09T20:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发自<a href="https://github.com/amfe/article/issues/8" target="_blank" rel="noopener">阿里无线前端博客</a></p><p><em>注：本文摘自阿里内网的无线前端博客《无线前端的图片相关工作流程梳理》。其实是一个月前写的，鉴于团队在<a href="http://css.w3ctech.com/" target="_blank" rel="noopener">中国第二届 CSS Conf</a> 上做了《手机淘宝 CSS 实践启示录》的分享，而图片工作流程梳理是其中的一个子话题，故在此一并分享出来，希望仍可以给大家一些经验和启发。另外，考虑到这是一篇公开分享，原版内容有部分删节和调整，里面有一些经验和产出是和我们的工作环境相关的，不完全具有普遍性，还请见谅。</em></p><p>今天很荣幸的跟大家分享一件事情，就是经过差不多半年多的努力，尤其是最近 2 周的“突击扫尾”，无线前端团队又在工具流程方面有了一个不小的突破：我们暂且称其为“图片工作流”梳理。</p><h3 id="图片！图片！图片！"><a href="#图片！图片！图片！" class="headerlink" title="图片！图片！图片！"></a>图片！图片！图片！</h3><p>要说最近 1 年里，无线前端开发的一线同学最“难搞”的几件事，图片处理绝对可以排在前三。</p><ul><li>首先，我们首先要从视觉稿 (绝大部分出自 photoshop) 里把图片合理的分解、测量、切割、导出——俗称“切图”</li><li>然后，我们要把切好的图放入页面代码中，完成相关的本地调试</li><li>第三步，把本地图片通过一个内部网站 (名叫 TPS) 上传到我们的图片 CDN 上，并复制图片的 CDN 地址，把本地调试用的相对路径替换掉</li><li>第四步，不同的图片、不同的外部环境下 (比如 3g 还是 wifi)，我们需要给图片不一样的尺寸、画质展现，并有一系列的配置需要遵循</li><li>如果视觉稿有更改 (不要小看这件事，微观上还是很频繁的哦)，不好意思，从第一步开始再重新走一遍……</li></ul><p>这里面“难搞”在哪些地方呢？我们逐一分析一下：</p><ol><li>“切图”的效率并不高，而且每一步都很容易出现返工或再沟通</li><li>打开 TPS 网站上传图片放到前端开发流程中并不是一个连贯流畅的步骤，而且 GUI 相比于命令行工具的缺陷在于无法和其它工具更好的集成</li><li>替换 CDN 图片路径的工作机械而繁琐，并且代码中替换后的图片地址失去了原本的可读性，非常容易造成后期的维护困惑甚至混乱</li><li>适配工作异常繁杂和辛苦，也很容易漏掉其中的某个环节</li><li>视觉变更的成本高，web 的快速响应的特点在丧失</li></ol><p>所以可能把这些东西画成一张图表的话：</p><p><img src="http://img2.tbcdn.cn/L1/461/1/58a8b4f12816b6f71918c31ee5a0ceae74f40fb9" alt=""></p><h3 id="团队的单点突破"><a href="#团队的单点突破" class="headerlink" title="团队的单点突破"></a>团队的单点突破</h3><p>在最近半年的一段时间里，无线前端团队先后发起了下面几项工作，从某个点上尝试解决这些问题：</p><a id="more"></a><h4 id="lib-flexible"><a href="#lib-flexible" class="headerlink" title="lib.flexible"></a>lib.flexible</h4><p>首先，我们和 UED 团队共同协商约定了一套 REM 方案 (后更名为 flexible 方案，进而演进为 lib.flexible 库)，通过对视觉稿的产出格式的约定，从工作流程的源头把控质量，同时在技术上产出了配套的 <a href="https://github.com/amfe/lib-flexible/" target="_blank" rel="noopener">lib.flexible</a> 库，可以“抹平”不同设备屏幕的尺寸差异，同时对清晰度进行了智能判断。这部分工作前端的部分是 @wintercn 寒老师和 @terrykingcha 共同创建的。</p><p><img src="http://img4.tbcdn.cn/L1/461/1/bd051f9dbea5cf39a1b087f552181ce509ca5c7f" alt=""></p><h4 id="视觉稿辅助工具普及"><a href="#视觉稿辅助工具普及" class="headerlink" title="视觉稿辅助工具普及"></a>视觉稿辅助工具普及</h4><p>其次，我们于去年 12 月开始启动了一个“视觉稿工具效率提升”的开放课题，由团队的 @songsiqi 负责牵头，我们从课题的一开始就确立了 KPI 和 roadmap，经过一段时间的调研和落实，收罗了很多实用的辅助工具帮助我们提升效率，同时布道给了整个团队。比如 <a href="http://www.cutterman.cn/" target="_blank" rel="noopener">cutterman</a>、<a href="http://www.cutterman.cn/parker" target="_blank" rel="noopener">parker</a>、<a href="https://github.com/romashamin/Size-Marks-PS" target="_blank" rel="noopener">Size Marks</a> 等</p><h4 id="img-uploader"><a href="#img-uploader" class="headerlink" title="img-uploader"></a>img-uploader</h4><p>在 @hongru 去年主持完成的一系列 One-Request 前端工具集当中，有一个很有意义的名叫 <code>or-uploadimg</code> 的图片上传工具。它把 TPS 的图片上传服务命令化了。这给我们对图片上传工作批量化、集成化提供了一个非常重要的基础！这个工具同时也和淘宝网前端团队的另一个 TPS 图片上传工具有异曲同工之妙。大概用法是这样的，大家可以感受一下：</p><pre><code>var uploader = require(&apos;@ali/or-uploadimg&apos;);// 上传 glob 多张图uploader(&apos;./**/*.jpg&apos;, function (list) {    console.log(list)});// 上传多张uploader([&apos;./1.jpg&apos;, &apos;./3d-base.jpg&apos;], function (list1, list2) {    console.log(list1, list2);})// 上传单张uploader(&apos;./3d-base.jpg&apos;, function (list1) {    console.log(list1)})</code></pre><p>随后团队又出现了这一工具的 <a href="http://gulpjs.com" target="_blank" rel="noopener">gulp</a> 插件，可以对图片上传的工作流程做一个简单的集成，具体集成方式是分析网页的 html/css 代码，找到其中的相对图片地址并上传+替换 CDN URL。</p><pre><code>var gulp = require(&apos;gulp&apos;);var imgex = require(&apos;@ali/gulp-imgex&apos;);gulp.task(&apos;imgex&apos;, function() {    gulp.src([&apos;./*.html&apos;])        .pipe(imgex())        .pipe(gulp.dest(&apos;./&apos;));    gulp.src(&apos;./css/*.css&apos;)        .pipe(imgex({            base64Limit: 8000, // base64化的图片size上限，小于这个size会直接base64化，否则上传cdn            uploadDest: &apos;tps&apos; // 或者 `mt`        }))        .pipe(gulp.dest(&apos;./css&apos;));});</code></pre><h4 id="lib-img"><a href="#lib-img" class="headerlink" title="lib.img"></a>lib.img</h4><p><code>lib.img</code> 是团队 @chenerlang666 主持开发的一个基础库，它是一套图片自动处理优化方案。可以同时解决屏幕尺寸判断、清晰度判断、网络环境判断、域名收敛、尺寸后缀计算、画质后缀计算、锐化度后缀计算、懒加载等一系列图片和性能相关的问题。这个库的意义和实用性都非常之高，并且始终保持着快速的业务响应和迭代周期，也算是无线前端团队的一个明星作品，也报送了当年度的无线技术金码奖。</p><p><img src="http://img1.tbcdn.cn/L1/461/1/b98433bdbbf29c3682b169bd3f004a22fc5935d1" alt=""></p><h4 id="px2rem"><a href="#px2rem" class="headerlink" title="px2rem"></a>px2rem</h4><p><a href="https://www.npmjs.com/package/px2rem" target="_blank" rel="noopener">px2rem</a> 是 @songsiqi 主持开发的另一个小工具，它因 lib.flexible 方案而生，因为我们统一采用 rem 单位来最终记录界面的尺寸，且对于个别1像素边框、文本字号来说，还有特殊的规则作为补充 (详见 lib.flexible 的文档)。</p><p><img src="http://img4.tbcdn.cn/L1/461/1/b78ccf6e3f3332e03751e6fbbec1abeec25bee1c" alt=""></p><p>同样的，它也有 <a href="https://www.npmjs.com/package/gulp-px2rem" target="_blank" rel="noopener">gulp</a> / browser 的各种版本。</p><h4 id="img4dpr"><a href="#img4dpr" class="headerlink" title="img4dpr"></a>img4dpr</h4><p><code>img4dpr</code> 则是一个可以把 CSS 中的 CDN URL 自动转成 3 种 dpr 下不同的尺寸后缀。算是对 lib.img 的一个补充。如果你的图片不是产生在 <code>&lt;img&gt;</code> 标签或 JavaScript 中，而是写在了 CSS 文件里，那么即使是 lib.img 恐怕也无能为力，img4dpr 恰恰是在解决这个问题。</p><p><img src="http://img1.tbcdn.cn/L1/461/1/d0d545549d5a93d5a717ac673c7d54701f0d4066" alt=""></p><h3 id="完事儿了吗？"><a href="#完事儿了吗？" class="headerlink" title="完事儿了吗？"></a>完事儿了吗？</h3><p>看上去，团队为团队做了很多事情，每件事情都在单点上有所突破，解决了一定的问题。</p><p>但我们并没有为此停止思考</p><p>有一个很明显的改进空间在这里：今天我们的前端开发流程是一整套工程链路，每个环节之间都紧密相扣， <strong>解决了单点的问题并不是终点，基于场景而不是功能点的思考方式，才能够把每个环节都流畅的串联起来，才能给前端开发者在业务支持的过程当中提供完美高效畅通无阻的体验——这是我们为之努力的更大的价值！也是我认为真正“临门一脚”的最终价值体现！</strong></p><h3 id="基于场景的思维方式"><a href="#基于场景的思维方式" class="headerlink" title="基于场景的思维方式"></a>基于场景的思维方式</h3><p><strong>这种思维方式听上去很玄幻，其实想做到很简单，我们不要单个儿看某个工具好不好用，牛不牛掰，模拟真实工程场景，创建个新项目，从“切图”的第一步连续走到发布的最后一步，看看中间哪里断掉了？哪里衔接的不自然？哪里不完备？哪里重复设计了？哪里可以整合？通常这些问题都会变得一目了然。</strong></p><p>首先，在 Photoshop 中“切图”本身的过程对于后续的开发流程来说是相对独立的，所以这里并没有做更多的融合 <em>(从另外一个角度看，这里其实有潜在的改造空间，如何让“切图”的工作也能集成到前端工具链路中，这值得我们长期思考)</em></p><p>然后，从图片导出产生的那一刻起，它所经历的场景大概会是这么几种：</p><ul><li>放入 <code>images</code> 文件夹<ul><li>to HTML<ul><li>src: (upload time) -&gt; set <code>[src]</code> -&gt; webpack require -&gt; hash filename (upload time) -&gt; file-loader</li><li>data-src<ul><li>(upload time) -&gt; set <code>[data-src]</code> -&gt; lib.img (auto resize)</li></ul></li></ul></li><li>to JavaScript: element.src, element.style.backgroundImage<ul><li>(upload time) -&gt; set <code>[data-src]</code> data</li><li>(upload time) -&gt; set <code>[src]</code> (manually resize)</li><li>(upload time) -&gt; set <code>element.style.background</code> -&gt; lib.img (manually resize)</li></ul></li><li>to CSS: background-image<ul><li>(upload time) -&gt; set <code>background</code> -&gt; postcss (upload time) -&gt; px2rem, img4dpr</li></ul></li></ul></li></ul><p>其中 <code>(upload time)</code> 指的是我有机会在这个时机把图片上传到 CDN 并把代码里的图片地址替换掉；<code>(* resize)</code> 指的是我有机会在这个时机把图片的域名收敛/尺寸/画质/锐化度等需求处理掉。</p><p>经过这样一整理，我们很容易发现问题：</p><ol><li>图片上传存在很多种可选的时机，并没有形成最佳实践</li><li>有些链路完全没有机会做必要的处理 (如 to HTML -&gt; src 的链路无法优化图片地址)</li><li>有些链路处理图片的逻辑并不够智能 (比如需要手动确定优化图片选项的链路)</li><li>图片上传 CDN 之后必须手动替换掉源代码里的图片路径，这个问题在任何一个链路里都没有得到解决</li><li>CSS 相关的小工具很多，比较零散，学习和使用的成本在逐步变高变复杂</li><li>没有统一完善的项目脚手架，大家创建新项目都需要初始化好多小工具的 gulp 配置 (当然有个土办法就是从就项目里 copy 一份 <code>package.json</code> 和一份 <code>gulpfile.js</code>)</li></ol><h3 id="基于场景的“查漏补缺”"><a href="#基于场景的“查漏补缺”" class="headerlink" title="基于场景的“查漏补缺”"></a>基于场景的“查漏补缺”</h3><p><img src="http://gtms03.alicdn.com/tps/i3/TB1xb2FIpXXXXb7XVXXtkvyUVXX-2048-1536.jpg" alt=""></p><p>在完善场景的“最后一公里”，我们做了如下的工作：</p><ol><li>把所有的 CSS 工具集成到了 postcss，再通过 postcss 的 gulp 插件、webpack 插件、browserify 插件令其未来有机会灵活运用到多种场景而不需要做多种工具链的适配，即：postcss-px2rem、postcss-img4dpr，同时额外的，借此机会引入 postcss-autoprefixer，让团队拜托旧的 webkit 前缀，拥抱标准的写法</li><li>把图片上传的时机由最早的 or-imgex-gulp 在最后阶段分析网页的html/css代码上传替换其中的图片，变为在 <code>images</code> 目录下约定一个名为 <code>_cdnurl.json</code> 的文件，记录图片的 hash 值和线上 CDN 地址，并写了一个 <code>@ali/gulp-img-uploader</code> 的 gulp 插件，每次运行的时候会便利 <code>images</code> 文件夹中的图片，如果出现新的 hash 值，就自动上传到 CDN，并把相应生成的 CDN URL 写入 <code>_cdnurl.json</code></li><li>同时，这个文件可以引入到页面的 JavaScript 环境中，引入到 img4dpr 工具中，引入到 lib.img 的逻辑中，让 HTML/CSS/JavaScript 的各种使用图片的场景都可以访问到 <code>_cdnurl.json</code> 中记录的本地图片路径和线上地址的对应关系</li><li>这也意味着 lib.img, img4dpr 需要做相应的改动，同时</li><li>页面本身要默认把 <code>_cdnurl.json</code> 的信息引入以做准备</li><li>创建一个 lib.cdnurl 的库，在图片未上传的情况下，返回本地路径，在已经上传的情况下，返回 CDN URL，这样通过这个库作支持，外加 lib.img、img4dpr，开发者可以做到在源代码中完全使用本地路径，源代码的可读性得到了最大程度的保证</li><li>基于 adam 创建一个包含全套工具链路的项目模板 (脚手架)</li></ol><p>上述几件事我们于上周一做了统一讨论和分工，这里要感谢 @mingelz @songsiqi @chenerlang666 的共同努力！！</p><h4 id="夹带私货-偷笑"><a href="#夹带私货-偷笑" class="headerlink" title="夹带私货 (偷笑)"></a>夹带私货 (偷笑)</h4><p>我在这个过程中，融入了之前一段时间集中实践的 <a href="http://jiongks.name/blog/just-vue/" target="_blank" rel="noopener">vue 和 webpack 的工程体系</a>，在 vue 的基础上进行组件化开发，在 webpack 的基础上管理资源打包、集成和发布，最终合并在了最新的 just-vue 的 adam template 里面。</p><p>之前不是在文章的最后卖了个“最后一公里”的关子吗，这里介绍的图片工作流改进就是其中的一部分：）</p><p>同时，我基于 lib.img 的思路，结合 vue.js 自身的特点，写了一个 <code>v-src</code> 的 directive，在做到 lib.img 里 <code>[data-src]</code> 相同目的的同时，更好的融入了 vue.js 的体系，同时加入了更高集成度的功能，稍后会再介绍。</p><p><strong>夹带了私货之后是不是我就没法用了？</strong></p><p>最后我想强调的是，除了自己的这些“私货”之外，上面提到的几个改进点和这些个人的内容是完全解耦的，如果你不选择 vue.js 或 webpack 而是别的同类型工具或自己研发的一套工具，它依然可以灵活的融入你的工作流程中。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>我们在团队内部把这些工作流程以脚手架的方式进行了沉淀，并放在了团队内部叫做 <code>adam</code> 的 generator 平台上 (后续会有介绍) 取名叫做 <code>just-vue</code> (时间仓促，adam 和相关的 generator 未来会在适当的时机开放出来)。大致用法：</p><p>安装 adam 和 just-vue 模板：</p><pre><code>tnpm install -g @ali/adamadam tmpl add &lt;just-vue git repo&gt;</code></pre><p>交互式初始化新项目：</p><pre><code>$ adam? Choose a template: just-vue? Project Name: y? Git User or Project Author: ...? Your email address: ...Awesome! Your project is created! |--.gitignore |--components |--|--foo.vue |--gulpfile.js |--images |--|--_cdnurl.json |--|--logo.png |--|--one.png |--|--taobao.jpg |--lib |--|--lib-cdnurl.js |--|--lib-img.js |--|--vue-src.js |--package.json |--README.md |--src |--|--main.html |--|--main.js |--|--main.vue</code></pre><h4 id="目录结构剖析"><a href="#目录结构剖析" class="headerlink" title="目录结构剖析"></a>目录结构剖析</h4><p>然后大家会看到项目目录里默认就有：</p><ul><li><code>gulpfile.js</code>，里面默认写好了图片批量上传并更新 <code>_cdnurl.json</code>、webpack 打包、htmlone 合并 等常见任务</li><li><code>images</code> 目录，里面放好了关键的 <code>_cdnurl.json</code>，还有几张图片作为示例，它们的 hash 和 CDN URL 已经写好了</li><li><code>src/main.*</code>，主页面入口，包括一个 htmlone 文件 (<code>main.html</code>)，一个 webpack 文件 (<code>main.js</code>) 和一个 vue 主文件 (<code>main.vue</code>)，默认引入了需要的所有样式和脚本，比如 lib.img, lib.flexible, lib.cdnurl, _cdnurl.json, v-src.js 等，我们将来主要的代码都会从 <code>main.vue</code> 写起——额外的，我们为 MT 模板开发者贴心的引入了默认的 mock 数据的 <code>&lt;script data-mt-variable=&quot;data&quot;&gt;</code> 标签，不需要 MT 模板开发环境的将其删掉即可</li><li><code>components</code> 目录，这里会把我们拆分下来的子组件都放在这里，我们示范性的放了一个 <code>foo.vue</code> 的组件在里面，并默认引入了 lib.cdnurl 库</li><li><code>lib</code> 这里默认放入了 lib.img, lib.cdnurl, v-src.js 几个库，这几个库在未来逐步稳定之后都会通过 tnpm + CommonJS 的方式进行管理，目前团队 tnpm + CommonJS 的组件整合还需要一定时间，这里是个方便调整迭代的临时状态。</li></ul><p>然后，我们来看一看 <code>main.vue</code> 里的细节，这才是真正让你真切感受到未来开发体验的地方。</p><h4 id="图片工作场景"><a href="#图片工作场景" class="headerlink" title="图片工作场景"></a>图片工作场景</h4><p>首先，新产生任何图片，尽管丢到 <code>images</code> 目录，别忘了起个好理解的文件名</p><h4 id="CSS-中的图片"><a href="#CSS-中的图片" class="headerlink" title="CSS 中的图片"></a>CSS 中的图片</h4><p>然后，在 <code>main.vue</code> 的第 11 行看到了一个 CSS 的 background-image 的场景，我们只是把 <code>url(../images/taobao.jpg)</code> 设为其背景图片：</p><pre><code>background-image: url(../images/taobao.jpg);</code></pre><p><strong>完成了！就这样！你在发布之前不需要再关注额外的事情了。没有手动上传图片、没有另外的GUI、没有重命名、没有 CDN 地址替换、没有图片地址优化、没有不可读的代码</strong></p><h4 id="HTML-中的图片"><a href="#HTML-中的图片" class="headerlink" title="HTML 中的图片"></a>HTML 中的图片</h4><p>我们再来看看 HTML 里的图片，来到 39 行：</p><pre><code>&lt;img id=&quot;test-img&quot; v-src=&quot;../images/one.png&quot; size=&quot;cover&quot;&gt;</code></pre><p><strong>一个 <code>[v-src]</code> 特性搞定！就这样！你在发布之前不需要再关注额外的事情了</strong> (这里 <code>[size]</code> 特性提供了更多的图片地址优化策略，篇幅有限，大家感兴趣可以移步到 <code>lib/vue-src.js</code> 看其中的实现原理)。</p><h4 id="JavaScript-中的图片"><a href="#JavaScript-中的图片" class="headerlink" title="JavaScript 中的图片"></a>JavaScript 中的图片</h4><p>最后再看看在 JavaScript 里使用图片，来到 68 行：</p><pre><code>this.$el.style.backgroundImage = &apos;url(&apos; + cdn(&apos;../images/logo.png&apos;) + &apos;)&apos;</code></pre><p><strong>只加入了一步 <code>cdn(...)</code> 的图片生成，也搞定了！就这样！你在发布之前不需要再关注额外的事情了。</strong></p><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>那有人可能会怀疑： <strong>“那你都说发布之前很方便，发布的时候会不会太麻烦啊？”</strong></p><p>好问题，发布就两行命令：</p><pre><code># 图片增量上传、webpack 打包、htmlone 合并，最终生成在 dist 目录gulp# 交互式上传到 awpawp</code></pre><p>正常的命令行反应是类似这样的：</p><pre><code>$ gulp[04:46:48] Using gulpfile ~/Sites/alibaba/samples/y/gulpfile.js[04:46:48] Starting &apos;images&apos;...uploaded ../images/logo.png e1ea82cb1c39656b925012efe60f22ea http://gw.alicdn.com/tfscom/TB1SDNqIFXXXXaTaXXX7WcCNVXX-400-400.pnguploaded ../images/one.png 64eb2181ebb96809c7202a162b9289fb http://gw.alicdn.com/tfscom/TB1G7JHIFXXXXbTXpXX_g.pNVXX-400-300.pnguploaded ../images/taobao.jpg 4771bae84dfc0e57f841147b86844363 http://gw.alicdn.com/tfscom/TB1f2xSIFXXXXa1XXXXuLfz_XXX-1125-422.jpg[04:46:48] Finished &apos;images&apos; after 46 ms[04:46:48] Starting &apos;bundle&apos;...[04:46:49] Version: webpack 1.10.1      Asset     Size  Chunks             Chunk Names    main.js  17.1 kB       0  [emitted]  mainmain.js.map  23.5 kB       0  [emitted]  main[04:46:49] Finished &apos;bundle&apos; after 1.28 s[04:46:49] Starting &apos;build&apos;...&quot;htmlone_temp/cdn_combo_1.css&quot; downloaded!&quot;htmlone_temp/cdn_combo_0.js&quot; downloaded![04:46:57] &gt;&gt; All html done![04:46:57] Finished &apos;build&apos; after 8.07 s[04:46:57] Starting &apos;default&apos;...done[04:46:57] Finished &apos;default&apos; after 130 μs$ awp (交互式过程略)</code></pre><p>你甚至可以写成一行：</p><pre><code>gulp &amp;&amp; awp</code></pre><p>最终这个初始化工程的示例页面的效果如下</p><p><img src="http://img4.tbcdn.cn/L1/461/1/a9b1d49e0461e8f7b652d4fac2bb21998eed638d" alt=""></p><h4 id="设计变更了？"><a href="#设计变更了？" class="headerlink" title="设计变更了？"></a>设计变更了？</h4><p>这条链路是我们之前最不愿意面对的，今天，我们来看看这条链路变成了什么，假设有一张设计图要换：</p><ol><li>在 Photoshop 里把图重新切下来</li><li>同名图片文件放入 <code>images</code> 文件夹</li><li>运行 <code>gulp &amp;&amp; awp</code></li></ol><p><strong>就这样！</strong></p><p>额外的，如果尺寸有变化，就加一步：更改相应的 CSS 尺寸代码</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在整个团队架构的过程中，大家都在不断尝试，如何以更贴近开发者真实场景的方式，还原真实的问题，找出切实有效的解决方案，而不仅仅是单个功能或特性。这样我们往往会找到问题的关键，用最精细有效的方式把工作的价值最大化。其实“基于场景的思维方式”不只是流程设计的专利，我们业务上的产品设计、交互设计更需要这样的思维。我个人也正是受到了一些产品经理朋友们的思维方式的影响，把这种方式运用在了我自己的工作内容当中。希望我们产出的这套方案能够给大家创造一些价值，更是向大家传递我们的心得体会，希望这样的思维方式和做事方式可以有更多更广的用武之地。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发自&lt;a href=&quot;https://github.com/amfe/article/issues/8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里无线前端博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文摘自阿里内网的无线前端博客《无线前端的图片相关工作流程梳理》。其实是一个月前写的，鉴于团队在&lt;a href=&quot;http://css.w3ctech.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国第二届 CSS Conf&lt;/a&gt; 上做了《手机淘宝 CSS 实践启示录》的分享，而图片工作流程梳理是其中的一个子话题，故在此一并分享出来，希望仍可以给大家一些经验和启发。另外，考虑到这是一篇公开分享，原版内容有部分删节和调整，里面有一些经验和产出是和我们的工作环境相关的，不完全具有普遍性，还请见谅。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;今天很荣幸的跟大家分享一件事情，就是经过差不多半年多的努力，尤其是最近 2 周的“突击扫尾”，无线前端团队又在工具流程方面有了一个不小的突破：我们暂且称其为“图片工作流”梳理。&lt;/p&gt;
&lt;h3 id=&quot;图片！图片！图片！&quot;&gt;&lt;a href=&quot;#图片！图片！图片！&quot; class=&quot;headerlink&quot; title=&quot;图片！图片！图片！&quot;&gt;&lt;/a&gt;图片！图片！图片！&lt;/h3&gt;&lt;p&gt;要说最近 1 年里，无线前端开发的一线同学最“难搞”的几件事，图片处理绝对可以排在前三。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，我们首先要从视觉稿 (绝大部分出自 photoshop) 里把图片合理的分解、测量、切割、导出——俗称“切图”&lt;/li&gt;
&lt;li&gt;然后，我们要把切好的图放入页面代码中，完成相关的本地调试&lt;/li&gt;
&lt;li&gt;第三步，把本地图片通过一个内部网站 (名叫 TPS) 上传到我们的图片 CDN 上，并复制图片的 CDN 地址，把本地调试用的相对路径替换掉&lt;/li&gt;
&lt;li&gt;第四步，不同的图片、不同的外部环境下 (比如 3g 还是 wifi)，我们需要给图片不一样的尺寸、画质展现，并有一系列的配置需要遵循&lt;/li&gt;
&lt;li&gt;如果视觉稿有更改 (不要小看这件事，微观上还是很频繁的哦)，不好意思，从第一步开始再重新走一遍……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里面“难搞”在哪些地方呢？我们逐一分析一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“切图”的效率并不高，而且每一步都很容易出现返工或再沟通&lt;/li&gt;
&lt;li&gt;打开 TPS 网站上传图片放到前端开发流程中并不是一个连贯流畅的步骤，而且 GUI 相比于命令行工具的缺陷在于无法和其它工具更好的集成&lt;/li&gt;
&lt;li&gt;替换 CDN 图片路径的工作机械而繁琐，并且代码中替换后的图片地址失去了原本的可读性，非常容易造成后期的维护困惑甚至混乱&lt;/li&gt;
&lt;li&gt;适配工作异常繁杂和辛苦，也很容易漏掉其中的某个环节&lt;/li&gt;
&lt;li&gt;视觉变更的成本高，web 的快速响应的特点在丧失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以可能把这些东西画成一张图表的话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.tbcdn.cn/L1/461/1/58a8b4f12816b6f71918c31ee5a0ceae74f40fb9&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;团队的单点突破&quot;&gt;&lt;a href=&quot;#团队的单点突破&quot; class=&quot;headerlink&quot; title=&quot;团队的单点突破&quot;&gt;&lt;/a&gt;团队的单点突破&lt;/h3&gt;&lt;p&gt;在最近半年的一段时间里，无线前端团队先后发起了下面几项工作，从某个点上尝试解决这些问题：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何让办公室政治最小化</title>
    <link href="https://jinjiang.github.io//blog/how-to-minimize-politics-in-your-company/"/>
    <id>https://jinjiang.github.io//blog/how-to-minimize-politics-in-your-company/</id>
    <published>2015-08-01T20:53:04.000Z</published>
    <updated>2015-08-02T20:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>来来来，看看办公室政治是个什么东西，以及如何将其最小化<br>翻译如有疏漏还请指正</p><p>译自：<a href="http://www.bhorowitz.com/how_to_minimize_politics_in_your_company" target="_blank" rel="noopener">How to Minimize Politics in Your Company</a> via <a href="http://www.bhorowitz.com" target="_blank" rel="noopener">www.bhorowitz.com</a></p><p><em>更新：跟身边一些朋友讨论之后，觉得之前翻译的标题“杜绝”言过了，还是规规矩矩翻译成了“最小化”</em></p><hr><blockquote><p>Who the f@#k you think you f$&amp;kin’ with<br>I’m the f%*kin’ boss</p><p>—Rick Ross, Hustlin’</p></blockquote><p>在我所有的从商经历中，我从没听过有人说：“我喜欢办公室政治”。但在我们的周围，令人深恶痛绝的政治又到处都是，甚至自己的公司就是如此。既然大家都不喜欢政治，那为什么它无处不在呢？</p><p>政治行为几乎都源自 CEO。也许你会觉得：“我讨厌政治，我也不关心政治，但是我的周围充满了政治气味。这显然不是我造成的。”很遗憾，你并不需要怎么关心政治就会让你的周围充斥政治手段。实际上，很少关心政治的 CEO 才会让办公室充斥政治手段。不关心政治的 CEO 们往往会直接助涨政治行为。</p><p>我这里说的政治，就是指员工追求自我职业发展多于价值产出和贡献。也许还有别样的政治类型，但是这类政治行为真的很烦。</p><a id="more"></a><h3 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h3><p>CEO 无意识的激励甚至有时刺激了政治行为，办公室政治由此而生。举个非常简单的例子，我们想象一下薪酬决策。作为一个 CEO，资深的员工会反复找你索要加薪。他们会提醒你自己得到的回报已经比市场行情低多了。他们甚至已经手握外面的 offer 了。你大可给他们加个薪。这听起来没什么问题，但你就这样强烈刺激了大家的政治行为。</p><p>尤其是你在为一些对你的业务毫无价值的东西做奖励，员工会在你主动为他们的杰出表现嘉奖之前赚取更多的回报。为什么这样做很糟糕？我们仔细分析一下：</p><ol><li>其他“好胜”的同学会立刻感到不爽。注意不管是这种不爽还是之前的奖励都和实际的业绩毫无关系。你得花很多精力处理这些跟业绩无关的鸟事。重要的是，如果你有能力上限 (competent board) 的话，你不可能给每个人预期之外的涨薪，所以这会变成一件“先到先得”的事情。</li><li>比较“与世无争”的 (但有可能很给力的) 同学会因为不关心政治而失去期末的涨薪。</li><li>公司全员都上了一课：会哭的孩子有奶吃，关心政治的人会加薪。让暴风雨来的更猛烈些吧。</li></ol><p>现在我们来到一个更复杂的例子。你的 CFO 找到你说他希望在管理方面更进一步。他说他希望最终成为 COO，想了解自己需要具备什么样的技能才能胜任公司的这一职位。作为一个积极的主管，你可能会鼓励他实现自己的梦想。你告诉他你觉得他将来一定会是一个合格的 COO，并且应该开发某些方面的技能。额外的，你告诉他应该在管理上变得够强，这样其他高管 (executes) 才会愿意为他工作。一周之后，你的另一个高管就来找你诉苦了。她说 CFO 问她愿不愿意为他工作。她说你看好他成为最终的 COO。你之前遇到过这种事情吗？恭喜你摊上大事儿了。</p><h3 id="如何政治最小化"><a href="#如何政治最小化" class="headerlink" title="如何政治最小化"></a>如何政治最小化</h3><h4 id="专家-vs-菜鸟"><a href="#专家-vs-菜鸟" class="headerlink" title="专家 vs. 菜鸟"></a>专家 vs. 菜鸟</h4><p>避免政治往往会觉得不自然。它挑战了诸如开明思想或鼓励员工发展等管理最佳实践。</p><p>管理高层和初级雇员的不同好比跟业余选手和职业拳手过招的不同。如果你跟一个普通人交手，你尽可自然为之不必担心。如果你想退一步，你可以先抬起你迈在前面的一只脚。如果你对垒一位专业拳手，估计就被击到了。职业拳手经过了年复一年的训练，他们善于利用你的每一处微小的失误。先抬起你迈在前面的一只脚向后退会让你在那一瞬间失去重心，这就是你的对手一直等待的机会。</p><p>同样的，如果你管理一名初级雇员，他们跟你探讨职业发展的时候，你大可忘掉那些顾虑随性作答。但就像我们之前看到的，在对待那些高度敏感的老家伙时就不一样了。为了不被政治手段击倒，你需要在这方面提炼自己的技巧。</p><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>我作为一个 CEO 发展至今，我发现三条非常有效的将政治最小化的秘诀</p><p><strong>1. 雇佣有正确目标的人</strong></p><p>我之前描述的例子可能卷入了有目标，但本质并不关心政治的人。并不是所有的情况都是这样的。毫无疑问，把你的公司政治搞成美国参议院级别的方式就是雇佣错误目标的人。正如 <a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB" target="_blank" rel="noopener">Andy Grove</a> 所说，正确的目标是把主管的个人成功和公司成功和公司产品的胜利息息相关。错误的目标是把主管的个人成功和公司的收入划清界限。</p><p><strong>2. 为潜在的政治行为建立严格的机制并坚持贯彻</strong></p><p>某些行动会助涨政治，比如这三点：</p><ul><li>绩效评估和薪酬调整</li><li>组织结构设计与调整</li><li>晋升</li></ul><p>我们来审视在每一种情况下，你该如何制定程序来杜绝不好的行为和政治的动机。</p><p><em>绩效管理和薪酬调整</em></p><p>公司的绩效管理和薪酬调整通常都有一些滞后。这并不意味着他们没有认可员工或不给员工加薪，这仅仅是因为他们仓促特许此事在政治手段面前是非常脆弱的。通过规范合理的结构、正规的绩效评估和薪酬评估，你会在更高的高度明确薪水和股票的涨幅情况。尤其对高管的薪酬调整尤为重要，因为这样做会杜绝政治。在上面的例子中，CEO 应该有一套滴水不漏的绩效和薪酬政策，并且跟高管明确他的薪酬会被其他所有人评估。理想状态下，高管的薪酬体系应该有董事会的参与。这会 a) 有助于更好的管理 b) 让意外更难出现。</p><p><em>组织结构设计与调整</em></p><p>如果你管理高级员工，他们会一次又一次希望扩展自己的职责范围。在上面的例子中，CFO 希望成为 COO。在其它情形下，市场的一把手都希望把销售和市场一起运作起来，或工程的一把手希望把研发和产品管理都握在手上。当有些人向你提出类似的要求时，你要非常小心作答，因为你所讲的每一句话都会变成定时炸弹。一般情况下最好什么都别说。最多问问为什么，并且要牢记不要对对方提及的原因做出任何回应和解释。如果你表明了你的想法，那它一定会被传出去的，谣言会变得到处都是，你的周围会被业务无关的讨论所淹没。你应该基于常规的考虑评估你的组织结构，为了做出正确的决定，你可以获取必要的信息，但不要把你的计划透露或暗示出去。一旦你做了决定，那么就立刻执行组织结构调整：别让谣言先传到园区里。</p><p><em>晋升</em></p><p>每次你的公司提拔某些人的时候，其他同级别的人都会对此指指点点，探讨这个人是因为业绩好还是会来事儿才得到晋升的。如果答案是后者，那么其他人的反应无外乎是下面这三种：</p><ol><li>他们闷闷不乐，感觉被低估了</li><li>他们表现出不认同，跟这个人对着干，并在背后使坏</li><li>他们决定也学这个人的政治手段，因此产生了更多不合理的晋升</li></ol><p>很明显哪种行为你都不希望看到。因此你必须有一个正式的、透明的、有正当理由的晋升流程来决定每个人的晋升。通常这个流程是由其他团队成员参与的 (一般晋升流程要让其他主管参与，这些主管的工作性质和这个人类似，高管的晋升流程里应该有董事会的参与)。这个流程的目的是两面的。一方面它会让组织相信公司至少是基于业绩进行晋升评估的，另一方面流程的结果足以充分解释你的晋升。</p><p><strong>3. 小心别人打来的“小报告”</strong></p><p>一旦你的组织壮大到一定规模，团队成员就会不断相互投诉和抱怨。有时这些批评是非常激进的。要非常小心留意你听到的话以及它背后传递的信息。如果单纯的没有任何防备的解答员工提出的问题，你很容易把你内心认同的信息传递出去。如果大家在公司认为你觉得某个高管不够好，这样的信息会迅速传播开来，并且不会有人求证真相的。最后，大家都不再相信那个“问题高管”，做事也不再有效率。</p><p>这里有两种典型的你会听到的抱怨：</p><ol><li>抱怨一个高管的行为</li><li>抱怨一个高管的能力和业绩</li></ol><p>对于第一种问题，一般最好的处理方式就是找投诉和被投诉的双方高管拉到一个小黑屋里当面把事情解释清楚。通常一个当面的沟通就可以挽回冲突和错误 (如有)。不要试图隔空解决问题，那样只会带来问题和政治。</p><p>第二种问题会更少见同时处理起来也更复杂。如果你的一个高管鼓起勇气质疑他同伴的能力，那么很有可能，这两个人之间有很严重的问题。如果你遇到了这种问题，你一般会得到下面两种回复中的一种：a) 你会从他们那里得知一些你已经知道的事情，或者 b) 他们会给你“惊喜”。</p><p>如果他们告诉你的是你已经知道的事情，那么最主要的问题就是你已经让这个问题存在太久了。不论你迟迟不解决问题的理由是什么，你把这件事拖太久了导致现在你的团队已经向这名主管发难。你必须用最快速度解决这个问题。基本上你是要解雇这名高管了，因为我看到过的高官们只有提升得自己业绩和技能的，却从没有重拾起团队的信任和支持的。</p><p>而如果你收到的是信息是你从未了解过的，那么你必须立刻打断他，让这位抱怨别人的高管明确，你没办法确定这个评判。你不希望在重新审视他的表现之前就做处理。你也不希望大家觉得投诉是万能的。一旦你终止了谈话，你必须立刻重新审视这名被抱怨的员工。如果你发现他表现的很好，那么你必须找出抱怨他的人的动机并把它处理好，不要让这种言论占上风。如果你发现这个员工确实有问题，那么再回到抱怨他的人提供的信息，这时你应该明确处理表现不好的人。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为 CEO，你必须系统的考虑自己的一言一行导致的结果。开放，负责，目标导向才是王道，尽量避免错误的激励方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来来来，看看办公室政治是个什么东西，以及如何将其最小化&lt;br&gt;翻译如有疏漏还请指正&lt;/p&gt;
&lt;p&gt;译自：&lt;a href=&quot;http://www.bhorowitz.com/how_to_minimize_politics_in_your_company&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to Minimize Politics in Your Company&lt;/a&gt; via &lt;a href=&quot;http://www.bhorowitz.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.bhorowitz.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;更新：跟身边一些朋友讨论之后，觉得之前翻译的标题“杜绝”言过了，还是规规矩矩翻译成了“最小化”&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Who the f@#k you think you f$&amp;amp;kin’ with&lt;br&gt;I’m the f%*kin’ boss&lt;/p&gt;
&lt;p&gt;—Rick Ross, Hustlin’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我所有的从商经历中，我从没听过有人说：“我喜欢办公室政治”。但在我们的周围，令人深恶痛绝的政治又到处都是，甚至自己的公司就是如此。既然大家都不喜欢政治，那为什么它无处不在呢？&lt;/p&gt;
&lt;p&gt;政治行为几乎都源自 CEO。也许你会觉得：“我讨厌政治，我也不关心政治，但是我的周围充满了政治气味。这显然不是我造成的。”很遗憾，你并不需要怎么关心政治就会让你的周围充斥政治手段。实际上，很少关心政治的 CEO 才会让办公室充斥政治手段。不关心政治的 CEO 们往往会直接助涨政治行为。&lt;/p&gt;
&lt;p&gt;我这里说的政治，就是指员工追求自我职业发展多于价值产出和贡献。也许还有别样的政治类型，但是这类政治行为真的很烦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue.js 源码学习笔记</title>
    <link href="https://jinjiang.github.io//blog/vue-code-review/"/>
    <id>https://jinjiang.github.io//blog/vue-code-review/</id>
    <published>2015-07-26T03:15:41.000Z</published>
    <updated>2018-02-05T17:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近饶有兴致的又把最新版 <a href="http://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 的源码学习了一下，觉得真心不错，个人觉得 Vue.js 的代码非常之优雅而且精辟，作者本身可能无 (bu) 意 (xie) 提及这些。那么，就让我来吧：）</p><h3 id="程序结构梳理"><a href="#程序结构梳理" class="headerlink" title="程序结构梳理"></a>程序结构梳理</h3><p><img src="http://img2.tbcdn.cn/L1/461/1/8142ef3fc2055839f1a93a933d80e17694b4f76b" alt="Vue 程序结构"></p><p>Vue.js 是一个非常典型的 MVVM 的程序结构，整个程序从最上层大概分为</p><ol><li>全局设计：包括全局接口、默认选项等</li><li>vm 实例设计：包括接口设计 (vm 原型)、实例初始化过程设计 (vm 构造函数)</li></ol><p>这里面大部分内容可以直接跟 Vue.js 的<a href="http://vuejs.org/api/" target="_blank" rel="noopener">官方 API 参考文档</a>对应起来，但文档里面没有且值得一提的是构造函数的设计，下面是我摘出的构造函数最核心的工作内容。</p><p><img src="http://img3.tbcdn.cn/L1/461/1/00049a09def4aff8d80f3bb7229e3f6d395426fb" alt="Vue 实例初始化"></p><p>整个实例初始化的过程中，重中之重就是把数据 (Model) 和视图 (View) 建立起关联关系。Vue.js 和诸多 MVVM 的思路是类似的，主要做了三件事：</p><ol><li>通过 observer 对 data 进行了监听，并且提供订阅某个数据项的变化的能力</li><li>把 template 解析成一段 document fragment，然后解析其中的 directive，得到每一个 directive 所依赖的数据项及其更新方法。比如 <code>v-text=&quot;message&quot;</code> 被解析之后 (这里仅作示意，实际程序逻辑会更严谨而复杂)：<ol><li>所依赖的数据项 <code>this.$data.message</code>，以及</li><li>相应的视图更新方法 <code>node.textContent = this.$data.message</code></li></ol></li><li>通过 watcher 把上述两部分结合起来，即把 directive 中的数据依赖订阅在对应数据的 observer 上，这样当数据变化的时候，就会触发 observer，进而触发相关依赖对应的视图更新方法，最后达到模板原本的关联效果。</li></ol><p>所以整个 vm 的核心，就是如何实现 observer, directive (parser), watcher 这三样东西</p><a id="more"></a><h3 id="文件结构梳理"><a href="#文件结构梳理" class="headerlink" title="文件结构梳理"></a>文件结构梳理</h3><p>Vue.js 源代码都存放在项目的 <code>src</code> 目录中，我们主要关注一下这个目录 (事实上 <code>test/unit/specs</code> 目录也值得一看，它是对应着每个源文件的测试用例)。</p><p><code>src</code> 目录下有多个并列的文件夹，每个文件夹都是一部分独立而完整的程序设计。不过在我看来，这些目录之前也是有更立体的关系的：</p><p><img src="http://img4.tbcdn.cn/L1/461/1/cb73a147451157e52500734c0d31665a9540adae" alt="Vue 文件结构"></p><ul><li>首先是 <code>api/*</code> 目录，这几乎是最“上层”的接口封装，实际的实现都埋在了其它文件夹里</li><li>然后是 <code>instance/init.js</code>，如果大家希望自顶向下了解所有 Vue.js 的工作原理的话，建议从这个文件开始看起<ul><li><code>instance/scope.js</code>：数据初始化，相关的子程序 (目录) 有 <code>observer/*</code>、<code>watcher.js</code>、<code>batcher.js</code>，而 <code>observer/dep.js</code> 又是数据观察和视图依赖相关联的关键</li><li><code>instance/compile.js</code>：视图初始化，相关的子程序 (目录) 有 <code>compiler/*</code>、<code>directive.js</code>、<code>parsers/*</code></li></ul></li><li>其它核心要素：<code>directives/*</code>、<code>element-directives/*</code>、<code>filters/*</code>、<code>transition/*</code></li><li>当然还有 <code>util/*</code> 目录，工具方法集合，其实还有一个类似的 <code>cache.js</code></li><li>最后是 <code>config.js</code> 默认配置项</li></ul><p>篇幅有限，如果大家有意“通读” Vue.js 的话，个人建议顺着上面的整体介绍来阅读赏析。</p><p>接下来是一些自己觉得值得一提的代码细节</p><h3 id="一些不容错过的代码-程序细节"><a href="#一些不容错过的代码-程序细节" class="headerlink" title="一些不容错过的代码/程序细节"></a>一些不容错过的代码/程序细节</h3><h4 id="this-eventsCount-是什么"><a href="#this-eventsCount-是什么" class="headerlink" title="this._eventsCount 是什么?"></a><code>this._eventsCount</code> 是什么?</h4><p>一开始看 <code>instance/init.js</code> 的时候，我立刻注意到一个细节，就是 <code>this._eventsCount = {}</code> 这句，后面还有注释</p><p><img src="http://img4.tbcdn.cn/L1/461/1/ba0408eb6b96275540a3584e8d2f54fc3e6fa143" alt="eventsCount1"></p><blockquote><p>for $broadcast optimization</p></blockquote><p>非常好奇，然后带着疑问继续看了下去，直到看到 <code>api/events.js</code> 中 <code>$broadcast</code> 方法的实现，才知道这是为了避免不必要的深度遍历：在有广播事件到来时，如果当前 vm 的 <code>_eventsCount</code> 为 <code>0</code>，则不必向其子 vm 继续传播该事件。而且这个文件稍后也有 <code>_eventsCount</code> 计数的实现方式。</p><p><img src="http://img2.tbcdn.cn/L1/461/1/c998cff73b20104c67f9a87d696fed2e505bfb5e" alt="eventsCount2"></p><p><img src="http://img2.tbcdn.cn/L1/461/1/d536a283e6f76e5ab82d1fb77abea50d86edefd1" alt="eventsCount3"></p><p>这是一种很巧妙同时也可以在很多地方运用的性能优化方法。</p><h4 id="数据更新的-diff-机制"><a href="#数据更新的-diff-机制" class="headerlink" title="数据更新的 diff 机制"></a>数据更新的 diff 机制</h4><p>前阵子有很多关于视图更新效率的讨论，我猜主要是因为 virtual dom 这个概念的提出而导致的吧。这次我详细看了一下 Vue.js 的相关实现原理。</p><p>实际上，视图更新效率的焦点问题主要在于大列表的更新和深层数据更新这两方面，而被热烈讨论的主要是前者 (后者是因为需求小还是没争议我就不得而知了)。所以这里着重介绍一下 <code>directives/repeat.js</code> 里对于列表更新的相关代码。</p><p><img src="http://img2.tbcdn.cn/L1/461/1/688d02febd3c3b0633bb89a8c6ed0d03111651de" alt="diff1"></p><p>首先 <code>diff(data, oldVms)</code> 这个函数的注释对整个比对更新机制做了个简要的阐述，大概意思是先比较新旧两个列表的 vm 的数据的状态，然后差量更新 DOM。</p><p><img src="http://img1.tbcdn.cn/L1/461/1/947041e58ac0648ef21c0a76f88c4dd21c1e10ca" alt="diff2"></p><p>第一步：遍历新列表里的每一项，如果该项的 vm 之前就存在，则打一个 <code>_reused</code> 的标 (这个字段我一开始看 <code>init.js</code> 的时候也是困惑的…… 看到这里才明白意思)，如果不存在对应的 vm，则创建一个新的。</p><p><img src="http://img3.tbcdn.cn/L1/461/1/befe4ad131b854f48a5db76d208d066b3fc92bf9" alt="diff3"></p><p>第二步：遍历旧列表里的每一项，如果 <code>_reused</code> 的标没有被打上，则说明新列表里已经没有它了，就地销毁该 vm。</p><p><img src="http://img3.tbcdn.cn/L1/461/1/734be56ff87ce5f7eab1f0c2dfeccf1980bfb4fe" alt="diff4"></p><p>第三步：整理新的 vm 在视图里的顺序，同时还原之前打上的 <code>_reused</code> 标。就此列表更新完成。</p><p>顺带提一句 Vue.js 的元素过渡动画处理 (<code>v-transition</code>) 也设计得非常巧妙，感兴趣的自己看吧，就不展开介绍了</p><h4 id="组件的-keep-alive-特性"><a href="#组件的-keep-alive-特性" class="headerlink" title="组件的 [keep-alive] 特性"></a>组件的 <code>[keep-alive]</code> 特性</h4><p><img src="http://img3.tbcdn.cn/L1/461/1/84c59f338de3b80f50df41aac16ef35fc7d96ee3" alt="keepAlive1"></p><p><img src="http://img4.tbcdn.cn/L1/461/1/aab1152e83634dcd06fdf1eb2d68aed37468c643" alt="keepAlive2"></p><p>Vue.js 为其组件设计了一个 <code>[keep-alive]</code> 的特性，如果这个特性存在，那么在组件被重复创建的时候，会通过缓存机制快速创建组件，以提升视图更新的性能。代码在 <code>directives/component.js</code>。</p><h4 id="数据监听机制"><a href="#数据监听机制" class="headerlink" title="数据监听机制"></a>数据监听机制</h4><p>如何监听某一个对象属性的变化呢？我们很容易想到 <code>Object.defineProperty</code> 这个 API，为此属性设计一个特殊的 getter/setter，然后在 setter 里触发一个函数，就可以达到监听的效果。</p><p><img src="http://img3.tbcdn.cn/L1/461/1/14830039350289177a948fc2a1c3af4f84ed07d2" alt="ob"></p><p>不过数组可能会有点麻烦，Vue.js 采取的是对几乎每一个可能改变数据的方法进行 prototype 更改：</p><p><img src="http://img1.tbcdn.cn/L1/461/1/82d90098f1f2f8c0d6499e950d6f42a1ed3d64b1" alt="ob_array1"></p><p>但这个策略主要面临两个问题：</p><ol><li>无法监听数据的 <code>length</code>，导致 <code>arr.length</code> 这样的数据改变无法被监听</li><li>通过角标更改数据，即类似 <code>arr[2] = 1</code> 这样的赋值操作，也无法被监听</li></ol><p>为此 Vue.js 在文档中明确提示不建议直接角标修改数据</p><p><img src="http://img4.tbcdn.cn/L1/461/1/d26e450e3d6cf2e9dfb85be44bb4d61a058fa43a" alt="ob_array2"></p><p>同时 Vue.js 提供了两个额外的“糖方法” <code>$set</code> 和 <code>$remove</code> 来弥补这方面限制带来的不便。整体上看这是个取舍有度的设计。我个人之前在设计数据绑定库的时候也采取了类似的设计 (一个半途而废的内部项目就不具体献丑了)，所以比较认同也有共鸣。</p><h4 id="path-解析器的状态机设计"><a href="#path-解析器的状态机设计" class="headerlink" title="path 解析器的状态机设计"></a>path 解析器的状态机设计</h4><p>首先要说 <code>parsers</code> 文件夹里有各种“财宝”等着大家挖掘！认真看一看一定不会后悔的</p><p><code>parsers/path.js</code> 主要的职责是可以把一个 JSON 数据里的某一个“路径”下的数据取出来，比如：</p><pre><code>var path = &apos;a.b[1].v&apos;var obj = {  a: {    b: [      {v: 1},      {v: 2},      {v: 3}    ]  }}parse(obj, path) // 2</code></pre><p>所以对 <code>path</code> 字符串的解析成为了它的关键。Vue.js 是通过状态机管理来实现对路径的解析的：</p><p><img src="http://img2.tbcdn.cn/L1/461/1/192c0ee1f09e39da97f478ac487fff1a7f41ee30" alt="state1"></p><p>咋一看很头大，不过如果再稍微梳理一下：</p><p><img src="http://img2.tbcdn.cn/L1/461/1/3acfc1236df2d6cd068dd8540e0b0baeb4b8916b" alt="state graph"></p><p>也许看得更清楚一点了，当然也能发现其中有一点小问题，就是源代码中 <code>inIdent</code> 这个状态是具有二义性的，它对应到了图中的三个地方，即 <code>in ident</code> 和两个 <code>in (quoted) ident</code>。</p><p>实际上，我在看代码的过程中<a href="https://github.com/yyx990803/vue/issues/1063" target="_blank" rel="noopener">顺手提交了这个 bug</a>，作者眼明手快，当天就进行了修复，现在最新的代码里已经不是这个样子了：</p><p><img src="http://img2.tbcdn.cn/L1/461/1/c3d6fbfe3fd1fec5d8bbb582b8785244107c1ce6" alt="state2"></p><p>而且状态机标识由字符串换成了数字常量，解析更准确的同时执行效率也会更高。</p><h3 id="一点自己的思考"><a href="#一点自己的思考" class="headerlink" title="一点自己的思考"></a>一点自己的思考</h3><p>首先是视图的解析过程，Vue.js 的策略是把 element 或 template string 先统一转换成 document fragment，然后再分解和解析其中的子组件和 directives。我觉得这里有一定的性能优化空间，毕竟 DOM 操作相比之余纯 JavaScript 运算还是会慢一些。</p><p>然后是基于移动端的思考，Vue.js 虽确实已经非常非常小巧了 (min+gzip 之后约 22 kb)，但它是否可以更小，继续抽象出常用的核心功能，同时更快速，也是个值得思考的问题。</p><p>第三我非常喜欢通过 Vue.js 进行模块化开发的模式，Vue 是否也可以借助类似 web components + virtual dom 的形态把这样的开发模式带到更多的领域，也是件很有意义的事情。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue.js 里的代码细节还不仅于此，比如：</p><ul><li><code>cache.js</code> 里的缓存机制设计和场景运用 (如在 <code>parsers/path.js</code> 中)</li><li><code>parsers/template.js</code> 里的 <code>cloneNode</code> 方法重写和对 HTML 自动补全机制的兼容</li><li>在开发和生产环境分别用注释结点和不可见文本结点作为视图的“占位符”等等</li></ul><p>自己也在阅读代码，了解 Vue.js 的同时学到了很多东西，同时我觉得代码实现只是 Vue.js 优秀的要素之一，整体的程序设计、API 设计、细节的取舍、项目的工程考量都非常棒！</p><p>总之，分享一些自己的收获和代码的细节，希望可以帮助大家开阔思路，提供灵感。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近饶有兴致的又把最新版 &lt;a href=&quot;http://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue.js&lt;/a&gt; 的源码学习了一下，觉得真心不错，个人觉得 Vue.js 的代码非常之优雅而且精辟，作者本身可能无 (bu) 意 (xie) 提及这些。那么，就让我来吧：）&lt;/p&gt;
&lt;h3 id=&quot;程序结构梳理&quot;&gt;&lt;a href=&quot;#程序结构梳理&quot; class=&quot;headerlink&quot; title=&quot;程序结构梳理&quot;&gt;&lt;/a&gt;程序结构梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://img2.tbcdn.cn/L1/461/1/8142ef3fc2055839f1a93a933d80e17694b4f76b&quot; alt=&quot;Vue 程序结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue.js 是一个非常典型的 MVVM 的程序结构，整个程序从最上层大概分为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局设计：包括全局接口、默认选项等&lt;/li&gt;
&lt;li&gt;vm 实例设计：包括接口设计 (vm 原型)、实例初始化过程设计 (vm 构造函数)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里面大部分内容可以直接跟 Vue.js 的&lt;a href=&quot;http://vuejs.org/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方 API 参考文档&lt;/a&gt;对应起来，但文档里面没有且值得一提的是构造函数的设计，下面是我摘出的构造函数最核心的工作内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/L1/461/1/00049a09def4aff8d80f3bb7229e3f6d395426fb&quot; alt=&quot;Vue 实例初始化&quot;&gt;&lt;/p&gt;
&lt;p&gt;整个实例初始化的过程中，重中之重就是把数据 (Model) 和视图 (View) 建立起关联关系。Vue.js 和诸多 MVVM 的思路是类似的，主要做了三件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 observer 对 data 进行了监听，并且提供订阅某个数据项的变化的能力&lt;/li&gt;
&lt;li&gt;把 template 解析成一段 document fragment，然后解析其中的 directive，得到每一个 directive 所依赖的数据项及其更新方法。比如 &lt;code&gt;v-text=&amp;quot;message&amp;quot;&lt;/code&gt; 被解析之后 (这里仅作示意，实际程序逻辑会更严谨而复杂)：&lt;ol&gt;
&lt;li&gt;所依赖的数据项 &lt;code&gt;this.$data.message&lt;/code&gt;，以及&lt;/li&gt;
&lt;li&gt;相应的视图更新方法 &lt;code&gt;node.textContent = this.$data.message&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通过 watcher 把上述两部分结合起来，即把 directive 中的数据依赖订阅在对应数据的 observer 上，这样当数据变化的时候，就会触发 observer，进而触发相关依赖对应的视图更新方法，最后达到模板原本的关联效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以整个 vm 的核心，就是如何实现 observer, directive (parser), watcher 这三样东西&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从原型到发布——“团队时间线” 1.0 开发心得</title>
    <link href="https://jinjiang.github.io//blog/try-fullstack-in-timeline-app/"/>
    <id>https://jinjiang.github.io//blog/try-fullstack-in-timeline-app/</id>
    <published>2015-06-26T20:13:56.000Z</published>
    <updated>2015-06-27T03:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将会记录我自己最近一周时间里，从产生“团队时间线”这个想法，到产品设计、交互设计、开发、迭代、再到 1.0 发布的整个过程。整件事情跨越了多个分工职能，所以这件事情虽然并不大，但对我来说是一种不一样的做事方式和经历，所以觉得应该记录下来。</p><p><img src="http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/06/1009213551.png" alt=""></p><p><img src="http://img1.tbcdn.cn/L1/461/1/08312508850019d9db1c250acd4ae15fb66053f9" alt="_2015_06_27_2_11_23"></p><p>“团队时间线”是个可视化展示团队所有同学时间分配/管理的平台。每个人都可以在“我的时间管理”页面极简的记录自己的时间，比如从某天到另外一天做了一个项目、或者昨天开了一个重要的会等等。</p><a id="more"></a><h3 id="从-idea-开始"><a href="#从-idea-开始" class="headerlink" title="从 idea 开始"></a>从 idea 开始</h3><p>(下面这段阐述偏管理思考，只对技术感兴趣的同学可以跳过)</p><p>为什么要做这件事情呢？是从一个我观察到的团队现状开始的：</p><ol><li>今天无线前端产品线基本上是人均2到3个项目在支持，几乎没有多人同时协作一个项目或一个任务</li><li>前端团队并不是以业务为颗粒度存在的团队，而是团队个人分别参与到不同业务线的工作当中，业务线团队自身也有各自的项目管理机制和丰富的经验</li></ol><p>我们通常，也应该做事专注在事情上，围绕着任务、业务目标，安排不同的人参与进来，在一起协作。但这样的方式给前端团队带来了很多管理上的死角，我们并没有以人为本，关注人的状态。张三在参与的两个项目里工作安排都是合理的，但是两份工作叠加在一个人身上的时候就不一定了，但任何单个项目团队的负责人都看不到这件事。</p><p>所以作为补充，我希望引入“团队时间线”，从人的维度换个角度来看问题。</p><p>还有一个和时间线概念很接近的东西是“甘特图”，市面上也有不少现成的组件库，我也参与开发过一个叫 jquery.gantt 的插件。但是同样的，甘特图是专注在团队共同做好一件事情上的，而不是以人为中心的，所以每一行基本是一个子任务，像瀑布一样一步步排下来，一件事情就能占满整个屏幕的宽度和高度。而我希望时间线是可以同时让大家一眼看到前端团队全局的工作状态的。所以甘特图其实不是我想要的东西。</p><p>汇总一下自己的想法：</p><ol><li>以人为本，专注一个人同时做多件事情时的时间管理问题</li><li>能够看到团队整体的工作状态，任务的精细管理由项目团队自己来做，不产生重复管理</li></ol><p>这就是“团队时间线”想法的由来</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>(下面这段描述请设计师和艺术家们轻拍……)</p><p><img src="http://image.uisdc.com/wp-content/uploads/2015/05/wireframe-mockup-prototype-differeces-1.jpg" alt=""></p><p>前两天看优设哥 (优秀网页设计) 有一篇<a href="http://www.uisdc.com/wireframe-mockup-prototype-differeces" target="_blank" rel="noopener">《术语小科普！聊聊线框稿、视觉稿与原型的区别》</a>的文章，很多人可能会觉得这都是“别人家的设计”，没见过周围有人设计界面先画手稿的啊？不都是直接PS么？而且很多产品和交互文档都是拿同类产品截图来的，做完项目都不知道这文档是我们写出来的还是竞争对手写出来的……</p><p><img src="http://image.uisdc.com/wp-content/uploads/2015/05/sy20150523-.png" alt=""></p><p>我自己觉得，也许对于牛掰的设计师来说，他们只是因为太牛掰了以至于可以脑补那些初级的设计手段罢了。反正自己没那个专业能力，还是照猫画虎中规中矩一点，所以就试着先画框线图，然后实现原型功能，再做出高保真视觉 (视觉稿)，再做出高保真原型来。走一遍自己认为比较“规矩“的流程</p><p><img src="http://img4.tbcdn.cn/L1/461/1/72fb3861788e347254093011ad2d57eeadee23dc" alt="_2015_06_27_2_55_25"></p><p><img src="http://img1.tbcdn.cn/L1/461/1/7cc8467fc8a828d6c5aad794956852052d1de553" alt="IMG_1435"></p><p>当然，凑巧我找到了一个利器——<a href="http://www.fiftythree.com/paper" target="_blank" rel="noopener">53 Paper</a> + <a href="http://www.fiftythree.com/pencil" target="_blank" rel="noopener">53 Pencil</a>，它可以把 iPad 变成你的画板，而且 app 本身的品质是非常之高的！我现在不光拿它来画框线图，而且开会也可以拿它当会议记录本。</p><h4 id="先把线框图画出来"><a href="#先把线框图画出来" class="headerlink" title="先把线框图画出来"></a>先把线框图画出来</h4><p><img src="http://img2.tbcdn.cn/L1/461/1/5f84ca794875b77a534fc19ca9fd8c56dae51db1" alt="IMG_1426"></p><p><img src="http://img2.tbcdn.cn/L1/461/1/70fcc37b36142deb3f5c9dff4792d15bab890fed" alt="IMG_1431"></p><p>然后趁热打铁，把组件划分出来，并定下来基本的几个组件名和方法/属性名</p><p><img src="http://img1.tbcdn.cn/L1/461/1/79b4a1148562ad9a6de3b67af9fd0a86e047436c" alt="IMG_1427"></p><p><img src="http://img4.tbcdn.cn/L1/461/1/5af8e7d5f282e7c05fc752cd2b63d44ef9b98543" alt="IMG_1428"></p><p><img src="http://img3.tbcdn.cn/L1/461/1/fe3c0abf0f7feddc60180cfe3dc9dbfa399f3a91" alt="IMG_1432"></p><p>整个的时间大概用了半个小时</p><h4 id="交互体验版本"><a href="#交互体验版本" class="headerlink" title="交互体验版本"></a>交互体验版本</h4><p>之后，我快速在 web 端实现了一个可交互的体验版本 (UI 很“抽象”，几乎没有美感可言)，大概用了一个晚上。包括时间线是可以在表头点击左右滚动的，且有平移的动画效果。</p><p><em>坦白讲，做到这个程度花费的时间比我想象中的少了很多，因为我用到了另外的开发利器，晚些时候介绍：）</em></p><p>有了这样的一个可操作版本，基本上就可以把设计好的功能和操作流程都走通一遍了。</p><p><img src="http://img2.tbcdn.cn/L1/461/1/d10d65b2539085f1dc1d6436a0110aebe575b330" alt="_2015_06_27_3_48_40"></p><p>我把做好的这个抽象版本发给某同事，得到这样的评价：</p><blockquote><p>作为一个死码农，觉得这代码比UI漂亮，哈哈～</p></blockquote><h4 id="Design-in-Browser"><a href="#Design-in-Browser" class="headerlink" title="Design in Browser"></a>Design in Browser</h4><p><img src="http://img3.tbcdn.cn/L1/461/1/3ae5708714ec762dc70590640fb6368e9c78948b" alt="_2015_06_27_3_46_37"></p><p>好吧，我紧接着就做了第三步：视觉设计，我直接利用团队已有的 Bootstrap 皮肤 + 浏览器就完成了这件事，用时 1 个小时，然后又发给了刚才那个同事：</p><blockquote><p>什么鬼，为什么突然就这么好看了<br>bootstrap，果然</p></blockquote><h4 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h4><p>但其实这个设计出来的页面是不能操作的，只是个静态效果。最后我又花了差不多半个小时时间，把静态效果套到之前的“抽象”界面中。第四部也完成了。前后差不多经过了 1 天时间。</p><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><p>前面已经卖了个关子了，能够用一个晚上搞定这个界面的全套功能，包括每个组件的完备性、交互反映、动画效果。Vue + webpack 功不可没，前几天我刚<a href="http://jiongks.name/blog/just-vue/" target="_blank" rel="noopener">博客介绍</a>过一些 vue + webpack 的内容，没错，就是用这一套技术基础快速搭建起来的。再加上前期产品设计的时候已经把组件划分和主要属性/方法命名都确定过了，所以整个开发过程完全是自顶向下的。大应用拆成子组件，子组件再拆成更小的组件；大函数写成几行伪代码，每行伪代码再拆成不同的子函数……非常之顺畅，几乎没有返工。很多地方的逻辑都是一次浏览器刷新就通过的 (那天工作状态也确实不错)</p><p><img src="http://img2.tbcdn.cn/L1/461/1/83973f5da5f461820be65649bb2d1eda57037f3a" alt="_2015_06_27_3_56_48"></p><p>除了之前博客介绍到的 vue 和 webpack 以及 gulpfile.js 我又加入了 htmlone 打包和 awp 发布等更高集成化的工作方式。让调试、打包、发布都非常简单省时。</p><h4 id="好用的库的积累"><a href="#好用的库的积累" class="headerlink" title="好用的库的积累"></a>好用的库的积累</h4><ul><li><a href="https://www.npmjs.com/package/xhr" target="_blank" rel="noopener">xhr</a>: 可以在浏览器端被依赖的 xhr 请求函数</li><li><a href="https://www.npmjs.com/package/parse-color" target="_blank" rel="noopener">parse-color</a>: 处理 CSS 中的颜色值，可以返回各种格式，用在了不同任务生成的不同颜色中，同时保证颜色是半透明的。</li></ul><h3 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h3><p>就在我正准备搭 Node 服务的时候，刚好找到了 @子之 子大爷，跟他聊起这件事，他也非常认同，后端的服务器设备、数据库环境和身份验证等机制都是现成的，于是大家一拍即合，迅速敲定了数据格式和服务器接口，数据基本都是通过 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 四个 HTTP 方法完成查询、增加、更新、删除某个工作任务的。</p><p>@子之 当时同时在处理的事情也比较多，但开发效率也是奇高的，早上跟他说了想法，晚上接口就准备好了。</p><h3 id="联调-amp-发布"><a href="#联调-amp-发布" class="headerlink" title="联调 &amp; 发布"></a>联调 &amp; 发布</h3><p>又经过几轮松散的调试，过了不到一周时间吧。想法、设计、前端、后端都已经完成了，我们对程序进行了部署。并开始在无线前端的导购产品小组和卖家产品小组中先试用起来。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如上所述，我在大概一周的时间里，参与并见证了“团队时间线”的从无到有。它给我带来的收获，一方面是从团队管理角度一个更好的方式，另一方面实践了很多自己专业范围以外的流程和事情，再一方面也实践了 vue + webpack 的项目流程设计。一举三得。</p><p>希望这些产品、经验和收获可以在未来产生更大的价值，尤其是后两者</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将会记录我自己最近一周时间里，从产生“团队时间线”这个想法，到产品设计、交互设计、开发、迭代、再到 1.0 发布的整个过程。整件事情跨越了多个分工职能，所以这件事情虽然并不大，但对我来说是一种不一样的做事方式和经历，所以觉得应该记录下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/06/1009213551.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.tbcdn.cn/L1/461/1/08312508850019d9db1c250acd4ae15fb66053f9&quot; alt=&quot;_2015_06_27_2_11_23&quot;&gt;&lt;/p&gt;
&lt;p&gt;“团队时间线”是个可视化展示团队所有同学时间分配/管理的平台。每个人都可以在“我的时间管理”页面极简的记录自己的时间，比如从某天到另外一天做了一个项目、或者昨天开了一个重要的会等等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
